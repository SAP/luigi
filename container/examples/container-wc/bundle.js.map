{"version":3,"file":"bundle.js","sources":["../node_modules/svelte/src/runtime/internal/utils.js","../node_modules/svelte/src/runtime/internal/lifecycle.js","../node_modules/svelte/src/runtime/internal/dom.js","../node_modules/svelte/src/runtime/internal/scheduler.js","../node_modules/svelte/src/runtime/internal/transitions.js","../node_modules/svelte/src/runtime/internal/Component.js","../src/constants/communication.ts","../src/constants/internal-communication.ts","../node_modules/svelte/src/runtime/internal/disclose-version/index.js","../node_modules/svelte/src/shared/version.js","../src/utilities/helpers.ts","../src/services/container.service.ts","../src/services/web-component-helpers.ts","../src/services/webcomponents.service.ts","../src/api/container-api.ts","../src/services/iframe-helpers.ts","../src/LuigiContainer.svelte","../src/LuigiCompoundContainer.svelte","../src/main.ts"],"sourcesContent":["/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n","import { custom_event } from './dom.js';\n\nexport let current_component;\n\n/** @returns {void} */\nexport function set_current_component(component) {\n\tcurrent_component = component;\n}\n\nexport function get_current_component() {\n\tif (!current_component) throw new Error('Function called outside component initialization');\n\treturn current_component;\n}\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tget_current_component().$$.before_update.push(fn);\n}\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tget_current_component().$$.on_mount.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tget_current_component().$$.after_update.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tget_current_component().$$.on_destroy.push(fn);\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap=any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst component = get_current_component();\n\treturn (type, detail, { cancelable = false } = {}) => {\n\t\tconst callbacks = component.$$.callbacks[type];\n\t\tif (callbacks) {\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = custom_event(/** @type {string} */ (type), detail, { cancelable });\n\t\t\tcallbacks.slice().forEach((fn) => {\n\t\t\t\tfn.call(component, event);\n\t\t\t});\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tget_current_component().$$.context.set(key, context);\n\treturn context;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\treturn get_current_component().$$.context.get(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\treturn get_current_component().$$.context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\treturn get_current_component().$$.context.has(key);\n}\n\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\n/**\n * @param component\n * @param event\n * @returns {void}\n */\nexport function bubble(component, event) {\n\tconst callbacks = component.$$.callbacks[event.type];\n\tif (callbacks) {\n\t\t// @ts-ignore\n\t\tcallbacks.slice().forEach((fn) => fn.call(this, event));\n\t}\n}\n","import { contenteditable_truthy_values, has_prop } from './utils.js';\n\nimport { ResizeObserverSingleton } from './ResizeObserverSingleton.js';\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\n\n/**\n * @returns {void}\n */\nexport function start_hydrating() {\n\tis_hydrating = true;\n}\n\n/**\n * @returns {void}\n */\nexport function end_hydrating() {\n\tis_hydrating = false;\n}\n\n/**\n * @param {number} low\n * @param {number} high\n * @param {(index: number) => number} key\n * @param {number} value\n * @returns {number}\n */\nfunction upper_bound(low, high, key, value) {\n\t// Return first index of value larger than input value in the range [low, high)\n\twhile (low < high) {\n\t\tconst mid = low + ((high - low) >> 1);\n\t\tif (key(mid) <= value) {\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\treturn low;\n}\n\n/**\n * @param {NodeEx} target\n * @returns {void}\n */\nfunction init_hydrate(target) {\n\tif (target.hydrate_init) return;\n\ttarget.hydrate_init = true;\n\t// We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n\n\tlet children = /** @type {ArrayLike<NodeEx2>} */ (target.childNodes);\n\t// If target is <head>, there may be children without claim_order\n\tif (target.nodeName === 'HEAD') {\n\t\tconst my_children = [];\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst node = children[i];\n\t\t\tif (node.claim_order !== undefined) {\n\t\t\t\tmy_children.push(node);\n\t\t\t}\n\t\t}\n\t\tchildren = my_children;\n\t}\n\t/*\n\t * Reorder claimed children optimally.\n\t * We can reorder claimed children optimally by finding the longest subsequence of\n\t * nodes that are already claimed in order and only moving the rest. The longest\n\t * subsequence of nodes that are claimed in order can be found by\n\t * computing the longest increasing subsequence of .claim_order values.\n\t *\n\t * This algorithm is optimal in generating the least amount of reorder operations\n\t * possible.\n\t *\n\t * Proof:\n\t * We know that, given a set of reordering operations, the nodes that do not move\n\t * always form an increasing subsequence, since they do not move among each other\n\t * meaning that they must be already ordered among each other. Thus, the maximal\n\t * set of nodes that do not move form a longest increasing subsequence.\n\t */\n\t// Compute longest increasing subsequence\n\t// m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n\tconst m = new Int32Array(children.length + 1);\n\t// Predecessor indices + 1\n\tconst p = new Int32Array(children.length);\n\tm[0] = -1;\n\tlet longest = 0;\n\tfor (let i = 0; i < children.length; i++) {\n\t\tconst current = children[i].claim_order;\n\t\t// Find the largest subsequence length such that it ends in a value less than our current value\n\t\t// upper_bound returns first greater value, so we subtract one\n\t\t// with fast path for when we are on the current longest subsequence\n\t\tconst seq_len =\n\t\t\t(longest > 0 && children[m[longest]].claim_order <= current\n\t\t\t\t? longest + 1\n\t\t\t\t: upper_bound(1, longest, (idx) => children[m[idx]].claim_order, current)) - 1;\n\t\tp[i] = m[seq_len] + 1;\n\t\tconst new_len = seq_len + 1;\n\t\t// We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n\t\tm[new_len] = i;\n\t\tlongest = Math.max(new_len, longest);\n\t}\n\t// The longest increasing subsequence of nodes (initially reversed)\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst lis = [];\n\t// The rest of the nodes, nodes that will be moved\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst to_move = [];\n\tlet last = children.length - 1;\n\tfor (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n\t\tlis.push(children[cur - 1]);\n\t\tfor (; last >= cur; last--) {\n\t\t\tto_move.push(children[last]);\n\t\t}\n\t\tlast--;\n\t}\n\tfor (; last >= 0; last--) {\n\t\tto_move.push(children[last]);\n\t}\n\tlis.reverse();\n\t// We sort the nodes being moved to guarantee that their insertion order matches the claim order\n\tto_move.sort((a, b) => a.claim_order - b.claim_order);\n\t// Finally, we move the nodes\n\tfor (let i = 0, j = 0; i < to_move.length; i++) {\n\t\twhile (j < lis.length && to_move[i].claim_order >= lis[j].claim_order) {\n\t\t\tj++;\n\t\t}\n\t\tconst anchor = j < lis.length ? lis[j] : null;\n\t\ttarget.insertBefore(to_move[i], anchor);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nexport function append(target, node) {\n\ttarget.appendChild(node);\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n * @returns {void}\n */\nexport function append_styles(target, style_sheet_id, styles) {\n\tconst append_styles_to = get_root_for_style(target);\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\n\t\tconst style = element('style');\n\t\tstyle.id = style_sheet_id;\n\t\tstyle.textContent = styles;\n\t\tappend_stylesheet(append_styles_to, style);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {ShadowRoot | Document}\n */\nexport function get_root_for_style(node) {\n\tif (!node) return document;\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\n\t\treturn /** @type {ShadowRoot} */ (root);\n\t}\n\treturn node.ownerDocument;\n}\n\n/**\n * @param {Node} node\n * @returns {CSSStyleSheet}\n */\nexport function append_empty_stylesheet(node) {\n\tconst style_element = element('style');\n\t// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,\n\t// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.\n\t// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.\n\t// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.\n\t// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.\n\tstyle_element.textContent = '/* empty */';\n\tappend_stylesheet(get_root_for_style(node), style_element);\n\treturn style_element.sheet;\n}\n\n/**\n * @param {ShadowRoot | Document} node\n * @param {HTMLStyleElement} style\n * @returns {CSSStyleSheet}\n */\nfunction append_stylesheet(node, style) {\n\tappend(/** @type {Document} */ (node).head || node, style);\n\treturn style.sheet;\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @returns {void}\n */\nexport function append_hydration(target, node) {\n\tif (is_hydrating) {\n\t\tinit_hydrate(target);\n\t\tif (\n\t\t\ttarget.actual_end_child === undefined ||\n\t\t\t(target.actual_end_child !== null && target.actual_end_child.parentNode !== target)\n\t\t) {\n\t\t\ttarget.actual_end_child = target.firstChild;\n\t\t}\n\t\t// Skip nodes of undefined ordering\n\t\twhile (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {\n\t\t\ttarget.actual_end_child = target.actual_end_child.nextSibling;\n\t\t}\n\t\tif (node !== target.actual_end_child) {\n\t\t\t// We only insert if the ordering of this node should be modified or the parent node is not target\n\t\t\tif (node.claim_order !== undefined || node.parentNode !== target) {\n\t\t\t\ttarget.insertBefore(node, target.actual_end_child);\n\t\t\t}\n\t\t} else {\n\t\t\ttarget.actual_end_child = node.nextSibling;\n\t\t}\n\t} else if (node.parentNode !== target || node.nextSibling !== null) {\n\t\ttarget.appendChild(node);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nexport function insert(target, node, anchor) {\n\ttarget.insertBefore(node, anchor || null);\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @param {NodeEx} [anchor]\n * @returns {void}\n */\nexport function insert_hydration(target, node, anchor) {\n\tif (is_hydrating && !anchor) {\n\t\tappend_hydration(target, node);\n\t} else if (node.parentNode !== target || node.nextSibling != anchor) {\n\t\ttarget.insertBefore(node, anchor || null);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nexport function detach(node) {\n\tif (node.parentNode) {\n\t\tnode.parentNode.removeChild(node);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function destroy_each(iterations, detaching) {\n\tfor (let i = 0; i < iterations.length; i += 1) {\n\t\tif (iterations[i]) iterations[i].d(detaching);\n\t}\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element(name) {\n\treturn document.createElement(name);\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @param {string} is\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element_is(name, is) {\n\treturn document.createElement(name, { is });\n}\n\n/**\n * @template T\n * @template {keyof T} K\n * @param {T} obj\n * @param {K[]} exclude\n * @returns {Pick<T, Exclude<keyof T, K>>}\n */\nexport function object_without_properties(obj, exclude) {\n\tconst target = /** @type {Pick<T, Exclude<keyof T, K>>} */ ({});\n\tfor (const k in obj) {\n\t\tif (\n\t\t\thas_prop(obj, k) &&\n\t\t\t// @ts-ignore\n\t\t\texclude.indexOf(k) === -1\n\t\t) {\n\t\t\t// @ts-ignore\n\t\t\ttarget[k] = obj[k];\n\t\t}\n\t}\n\treturn target;\n}\n\n/**\n * @template {keyof SVGElementTagNameMap} K\n * @param {K} name\n * @returns {SVGElement}\n */\nexport function svg_element(name) {\n\treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\n/**\n * @param {string} data\n * @returns {Text}\n */\nexport function text(data) {\n\treturn document.createTextNode(data);\n}\n\n/**\n * @returns {Text} */\nexport function space() {\n\treturn text(' ');\n}\n\n/**\n * @returns {Text} */\nexport function empty() {\n\treturn text('');\n}\n\n/**\n * @param {string} content\n * @returns {Comment}\n */\nexport function comment(content) {\n\treturn document.createComment(content);\n}\n\n/**\n * @param {EventTarget} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @returns {() => void}\n */\nexport function listen(node, event, handler, options) {\n\tnode.addEventListener(event, handler, options);\n\treturn () => node.removeEventListener(event, handler, options);\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function prevent_default(fn) {\n\treturn function (event) {\n\t\tevent.preventDefault();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopPropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_immediate_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopImmediatePropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function self(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.target === this) fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function trusted(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.isTrusted) fn.call(this, event);\n\t};\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nexport function attr(node, attribute, value) {\n\tif (value == null) node.removeAttribute(attribute);\n\telse if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_attributes(node, attributes) {\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n\tfor (const key in attributes) {\n\t\tif (attributes[key] == null) {\n\t\t\tnode.removeAttribute(key);\n\t\t} else if (key === 'style') {\n\t\t\tnode.style.cssText = attributes[key];\n\t\t} else if (key === '__value') {\n\t\t\t/** @type {any} */ (node).value = node[key] = attributes[key];\n\t\t} else if (\n\t\t\tdescriptors[key] &&\n\t\t\tdescriptors[key].set &&\n\t\t\talways_set_through_set_attribute.indexOf(key) === -1\n\t\t) {\n\t\t\tnode[key] = attributes[key];\n\t\t} else {\n\t\t\tattr(node, key, attributes[key]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_svg_attributes(node, attributes) {\n\tfor (const key in attributes) {\n\t\tattr(node, key, attributes[key]);\n\t}\n}\n\n/**\n * @param {Record<string, unknown>} data_map\n * @returns {void}\n */\nexport function set_custom_element_data_map(node, data_map) {\n\tObject.keys(data_map).forEach((key) => {\n\t\tset_custom_element_data(node, key, data_map[key]);\n\t});\n}\n\n/**\n * @returns {void} */\nexport function set_custom_element_data(node, prop, value) {\n\tconst lower = prop.toLowerCase(); // for backwards compatibility with existing behavior we do lowercase first\n\tif (lower in node) {\n\t\tnode[lower] = typeof node[lower] === 'boolean' && value === '' ? true : value;\n\t} else if (prop in node) {\n\t\tnode[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n\t} else {\n\t\tattr(node, prop, value);\n\t}\n}\n\n/**\n * @param {string} tag\n */\nexport function set_dynamic_element_data(tag) {\n\treturn /-/.test(tag) ? set_custom_element_data_map : set_attributes;\n}\n\n/**\n * @returns {void}\n */\nexport function xlink_attr(node, attribute, value) {\n\tnode.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @returns {string}\n */\nexport function get_svelte_dataset(node) {\n\treturn node.dataset.svelteH;\n}\n\n/**\n * @returns {unknown[]} */\nexport function get_binding_group_value(group, __value, checked) {\n\tconst value = new Set();\n\tfor (let i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) value.add(group[i].__value);\n\t}\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\treturn Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement[]} group\n * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}\n */\nexport function init_binding_group(group) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\treturn {\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\t_inputs.forEach((input) => group.push(input));\n\t\t},\n\t\t/* remove */ r() {\n\t\t\t_inputs.forEach((input) => group.splice(group.indexOf(input), 1));\n\t\t}\n\t};\n}\n\n/**\n * @param {number[]} indexes\n * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}\n */\nexport function init_binding_group_dynamic(group, indexes) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _group = get_binding_group(group);\n\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\n\tfunction get_binding_group(group) {\n\t\tfor (let i = 0; i < indexes.length; i++) {\n\t\t\tgroup = group[indexes[i]] = group[indexes[i]] || [];\n\t\t}\n\t\treturn group;\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction push() {\n\t\t_inputs.forEach((input) => _group.push(input));\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction remove() {\n\t\t_inputs.forEach((input) => _group.splice(_group.indexOf(input), 1));\n\t}\n\treturn {\n\t\t/* update */ u(new_indexes) {\n\t\t\tindexes = new_indexes;\n\t\t\tconst new_group = get_binding_group(group);\n\t\t\tif (new_group !== _group) {\n\t\t\t\tremove();\n\t\t\t\t_group = new_group;\n\t\t\t\tpush();\n\t\t\t}\n\t\t},\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\tpush();\n\t\t},\n\t\t/* remove */ r: remove\n\t};\n}\n\n/** @returns {number} */\nexport function to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/** @returns {any[]} */\nexport function time_ranges_to_array(ranges) {\n\tconst array = [];\n\tfor (let i = 0; i < ranges.length; i += 1) {\n\t\tarray.push({ start: ranges.start(i), end: ranges.end(i) });\n\t}\n\treturn array;\n}\n\n/**\n * @param {Element} element\n * @returns {ChildNode[]}\n */\nexport function children(element) {\n\treturn Array.from(element.childNodes);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {void}\n */\nfunction init_claim_info(nodes) {\n\tif (nodes.claim_info === undefined) {\n\t\tnodes.claim_info = { last_index: 0, total_claimed: 0 };\n\t}\n}\n\n/**\n * @template {ChildNodeEx} R\n * @param {ChildNodeArray} nodes\n * @param {(node: ChildNodeEx) => node is R} predicate\n * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} process_node\n * @param {() => R} create_node\n * @param {boolean} dont_update_last_index\n * @returns {R}\n */\nfunction claim_node(nodes, predicate, process_node, create_node, dont_update_last_index = false) {\n\t// Try to find nodes in an order such that we lengthen the longest increasing subsequence\n\tinit_claim_info(nodes);\n\tconst result_node = (() => {\n\t\t// We first try to find an element after the previous one\n\t\tfor (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// Otherwise, we try to find one before\n\t\t// We iterate in reverse so that we don't go too far back\n\t\tfor (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t} else if (replacement === undefined) {\n\t\t\t\t\t// Since we spliced before the last_index, we decrease it\n\t\t\t\t\tnodes.claim_info.last_index--;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// If we can't find any matching node, we create a new one\n\t\treturn create_node();\n\t})();\n\tresult_node.claim_order = nodes.claim_info.total_claimed;\n\tnodes.claim_info.total_claimed += 1;\n\treturn result_node;\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @param {(name: string) => Element | SVGElement} create_element\n * @returns {Element | SVGElement}\n */\nfunction claim_element_base(nodes, name, attributes, create_element) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Element | SVGElement} */\n\t\t(node) => node.nodeName === name,\n\t\t/** @param {Element} node */\n\t\t(node) => {\n\t\t\tconst remove = [];\n\t\t\tfor (let j = 0; j < node.attributes.length; j++) {\n\t\t\t\tconst attribute = node.attributes[j];\n\t\t\t\tif (!attributes[attribute.name]) {\n\t\t\t\t\tremove.push(attribute.name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tremove.forEach((v) => node.removeAttribute(v));\n\t\t\treturn undefined;\n\t\t},\n\t\t() => create_element(name)\n\t);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_svg_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, svg_element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Text}\n */\nexport function claim_text(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Text} */\n\t\t(node) => node.nodeType === 3,\n\t\t/** @param {Text} node */\n\t\t(node) => {\n\t\t\tconst data_str = '' + data;\n\t\t\tif (node.data.startsWith(data_str)) {\n\t\t\t\tif (node.data.length !== data_str.length) {\n\t\t\t\t\treturn node.splitText(data_str.length);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode.data = data_str;\n\t\t\t}\n\t\t},\n\t\t() => text(data),\n\t\ttrue // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n\t);\n}\n\n/**\n * @returns {Text} */\nexport function claim_space(nodes) {\n\treturn claim_text(nodes, ' ');\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Comment}\n */\nexport function claim_comment(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Comment} */\n\t\t(node) => node.nodeType === 8,\n\t\t/** @param {Comment} node */\n\t\t(node) => {\n\t\t\tnode.data = '' + data;\n\t\t\treturn undefined;\n\t\t},\n\t\t() => comment(data),\n\t\ttrue\n\t);\n}\n\nfunction get_comment_idx(nodes, text, start) {\n\tfor (let i = start; i < nodes.length; i += 1) {\n\t\tconst node = nodes[i];\n\t\tif (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * @param {boolean} is_svg\n * @returns {HtmlTagHydration}\n */\nexport function claim_html_tag(nodes, is_svg) {\n\t// find html opening tag\n\tconst start_index = get_comment_idx(nodes, 'HTML_TAG_START', 0);\n\tconst end_index = get_comment_idx(nodes, 'HTML_TAG_END', start_index + 1);\n\tif (start_index === -1 || end_index === -1) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\n\tinit_claim_info(nodes);\n\tconst html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n\tdetach(html_tag_nodes[0]);\n\tdetach(html_tag_nodes[html_tag_nodes.length - 1]);\n\tconst claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n\tif (claimed_nodes.length === 0) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\tfor (const n of claimed_nodes) {\n\t\tn.claim_order = nodes.claim_info.total_claimed;\n\t\tnodes.claim_info.total_claimed += 1;\n\t}\n\treturn new HtmlTagHydration(is_svg, claimed_nodes);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data(text, data) {\n\tdata = '' + data;\n\tif (text.data === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data_contenteditable(text, data) {\n\tdata = '' + data;\n\tif (text.wholeText === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @param {string} attr_value\n * @returns {void}\n */\nexport function set_data_maybe_contenteditable(text, data, attr_value) {\n\tif (~contenteditable_truthy_values.indexOf(attr_value)) {\n\t\tset_data_contenteditable(text, data);\n\t} else {\n\t\tset_data(text, data);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_input_value(input, value) {\n\tinput.value = value == null ? '' : value;\n}\n\n/**\n * @returns {void} */\nexport function set_input_type(input, type) {\n\ttry {\n\t\tinput.type = type;\n\t} catch (e) {\n\t\t// do nothing\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_style(node, key, value, important) {\n\tif (value == null) {\n\t\tnode.style.removeProperty(key);\n\t} else {\n\t\tnode.style.setProperty(key, value, important ? 'important' : '');\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_option(select, value, mounting) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\tif (option.__value === value) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_options(select, value) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\toption.selected = ~value.indexOf(option.__value);\n\t}\n}\n\nexport function select_value(select) {\n\tconst selected_option = select.querySelector(':checked');\n\treturn selected_option && selected_option.__value;\n}\n\nexport function select_multiple_value(select) {\n\treturn [].map.call(select.querySelectorAll(':checked'), (option) => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\n\n/**\n * @type {boolean} */\nlet crossorigin;\n\n/**\n * @returns {boolean} */\nexport function is_crossorigin() {\n\tif (crossorigin === undefined) {\n\t\tcrossorigin = false;\n\t\ttry {\n\t\t\tif (typeof window !== 'undefined' && window.parent) {\n\t\t\t\tvoid window.parent.document;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tcrossorigin = true;\n\t\t}\n\t}\n\treturn crossorigin;\n}\n\n/**\n * @param {HTMLElement} node\n * @param {() => void} fn\n * @returns {() => void}\n */\nexport function add_iframe_resize_listener(node, fn) {\n\tconst computed_style = getComputedStyle(node);\n\tif (computed_style.position === 'static') {\n\t\tnode.style.position = 'relative';\n\t}\n\tconst iframe = element('iframe');\n\tiframe.setAttribute(\n\t\t'style',\n\t\t'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n\t\t\t'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;'\n\t);\n\tiframe.setAttribute('aria-hidden', 'true');\n\tiframe.tabIndex = -1;\n\tconst crossorigin = is_crossorigin();\n\n\t/**\n\t * @type {() => void}\n\t */\n\tlet unsubscribe;\n\tif (crossorigin) {\n\t\tiframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n\t\tunsubscribe = listen(\n\t\t\twindow,\n\t\t\t'message',\n\t\t\t/** @param {MessageEvent} event */ (event) => {\n\t\t\t\tif (event.source === iframe.contentWindow) fn();\n\t\t\t}\n\t\t);\n\t} else {\n\t\tiframe.src = 'about:blank';\n\t\tiframe.onload = () => {\n\t\t\tunsubscribe = listen(iframe.contentWindow, 'resize', fn);\n\t\t\t// make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n\t\t\t// see https://github.com/sveltejs/svelte/issues/4233\n\t\t\tfn();\n\t\t};\n\t}\n\tappend(node, iframe);\n\treturn () => {\n\t\tif (crossorigin) {\n\t\t\tunsubscribe();\n\t\t} else if (unsubscribe && iframe.contentWindow) {\n\t\t\tunsubscribe();\n\t\t}\n\t\tdetach(iframe);\n\t};\n}\nexport const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'content-box'\n});\nexport const resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'border-box'\n});\nexport const resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton(\n\t{ box: 'device-pixel-content-box' }\n);\nexport { ResizeObserverSingleton };\n\n/**\n * @returns {void} */\nexport function toggle_class(element, name, toggle) {\n\t// The `!!` is required because an `undefined` flag means flipping the current state.\n\telement.classList.toggle(name, !!toggle);\n}\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]\n * @returns {CustomEvent<T>}\n */\nexport function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * @param {string} selector\n * @param {HTMLElement} parent\n * @returns {ChildNodeArray}\n */\nexport function query_selector_all(selector, parent = document.body) {\n\treturn Array.from(parent.querySelectorAll(selector));\n}\n\n/**\n * @param {string} nodeId\n * @param {HTMLElement} head\n * @returns {any[]}\n */\nexport function head_selector(nodeId, head) {\n\tconst result = [];\n\tlet started = 0;\n\tfor (const node of head.childNodes) {\n\t\tif (node.nodeType === 8 /* comment node */) {\n\t\t\tconst comment = node.textContent.trim();\n\t\t\tif (comment === `HEAD_${nodeId}_END`) {\n\t\t\t\tstarted -= 1;\n\t\t\t\tresult.push(node);\n\t\t\t} else if (comment === `HEAD_${nodeId}_START`) {\n\t\t\t\tstarted += 1;\n\t\t\t\tresult.push(node);\n\t\t\t}\n\t\t} else if (started > 0) {\n\t\t\tresult.push(node);\n\t\t}\n\t}\n\treturn result;\n}\n/** */\nexport class HtmlTag {\n\t/**\n\t * @private\n\t * @default false\n\t */\n\tis_svg = false;\n\t/** parent for creating node */\n\te = undefined;\n\t/** html tag nodes */\n\tn = undefined;\n\t/** target */\n\tt = undefined;\n\t/** anchor */\n\ta = undefined;\n\tconstructor(is_svg = false) {\n\t\tthis.is_svg = is_svg;\n\t\tthis.e = this.n = null;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tthis.h(html);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @param {HTMLElement | SVGElement} target\n\t * @param {HTMLElement | SVGElement} anchor\n\t * @returns {void}\n\t */\n\tm(html, target, anchor = null) {\n\t\tif (!this.e) {\n\t\t\tif (this.is_svg)\n\t\t\t\tthis.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));\n\t\t\t/** #7364  target for <template> may be provided as #document-fragment(11) */ else\n\t\t\t\tthis.e = element(\n\t\t\t\t\t/** @type {keyof HTMLElementTagNameMap} */ (\n\t\t\t\t\t\ttarget.nodeType === 11 ? 'TEMPLATE' : target.nodeName\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\tthis.t =\n\t\t\t\ttarget.tagName !== 'TEMPLATE'\n\t\t\t\t\t? target\n\t\t\t\t\t: /** @type {HTMLTemplateElement} */ (target).content;\n\t\t\tthis.c(html);\n\t\t}\n\t\tthis.i(anchor);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\th(html) {\n\t\tthis.e.innerHTML = html;\n\t\tthis.n = Array.from(\n\t\t\tthis.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes\n\t\t);\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert(this.t, this.n[i], anchor);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tp(html) {\n\t\tthis.d();\n\t\tthis.h(html);\n\t\tthis.i(this.a);\n\t}\n\n\t/**\n\t * @returns {void} */\n\td() {\n\t\tthis.n.forEach(detach);\n\t}\n}\n\nexport class HtmlTagHydration extends HtmlTag {\n\t/** @type {Element[]} hydration claimed nodes */\n\tl = undefined;\n\n\tconstructor(is_svg = false, claimed_nodes) {\n\t\tsuper(is_svg);\n\t\tthis.e = this.n = null;\n\t\tthis.l = claimed_nodes;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tif (this.l) {\n\t\t\tthis.n = this.l;\n\t\t} else {\n\t\t\tsuper.c(html);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert_hydration(this.t, this.n[i], anchor);\n\t\t}\n\t}\n}\n\n/**\n * @param {NamedNodeMap} attributes\n * @returns {{}}\n */\nexport function attribute_to_object(attributes) {\n\tconst result = {};\n\tfor (const attribute of attributes) {\n\t\tresult[attribute.name] = attribute.value;\n\t}\n\treturn result;\n}\n\nconst escaped = {\n\t'\"': '&quot;',\n\t'&': '&amp;',\n\t'<': '&lt;'\n};\n\nconst regex_attribute_characters_to_escape = /[\"&<]/g;\n\n/**\n * Note that the attribute itself should be surrounded in double quotes\n * @param {any} attribute\n */\nfunction escape_attribute(attribute) {\n\treturn String(attribute).replace(regex_attribute_characters_to_escape, (match) => escaped[match]);\n}\n\n/**\n * @param {Record<string, string>} attributes\n */\nexport function stringify_spread(attributes) {\n\tlet str = ' ';\n\tfor (const key in attributes) {\n\t\tif (attributes[key] != null) {\n\t\t\tstr += `${key}=\"${escape_attribute(attributes[key])}\" `;\n\t\t}\n\t}\n\n\treturn str;\n}\n\n/**\n * @param {HTMLElement} element\n * @returns {{}}\n */\nexport function get_custom_elements_slots(element) {\n\tconst result = {};\n\telement.childNodes.forEach(\n\t\t/** @param {Element} node */ (node) => {\n\t\t\tresult[node.slot || 'default'] = true;\n\t\t}\n\t);\n\treturn result;\n}\n\nexport function construct_svelte_component(component, props) {\n\treturn new component(props);\n}\n\n/**\n * @typedef {Node & {\n * \tclaim_order?: number;\n * \thydrate_init?: true;\n * \tactual_end_child?: NodeEx;\n * \tchildNodes: NodeListOf<NodeEx>;\n * }} NodeEx\n */\n\n/** @typedef {ChildNode & NodeEx} ChildNodeEx */\n\n/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */\n\n/**\n * @typedef {ChildNodeEx[] & {\n * \tclaim_info?: {\n * \t\tlast_index: number;\n * \t\ttotal_claimed: number;\n * \t};\n * }} ChildNodeArray\n */\n","import { run_all } from './utils.js';\nimport { current_component, set_current_component } from './lifecycle.js';\n\nexport const dirty_components = [];\nexport const intros = { enabled: false };\nexport const binding_callbacks = [];\n\nlet render_callbacks = [];\n\nconst flush_callbacks = [];\n\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\n\nlet update_scheduled = false;\n\n/** @returns {void} */\nexport function schedule_update() {\n\tif (!update_scheduled) {\n\t\tupdate_scheduled = true;\n\t\tresolved_promise.then(flush);\n\t}\n}\n\n/** @returns {Promise<void>} */\nexport function tick() {\n\tschedule_update();\n\treturn resolved_promise;\n}\n\n/** @returns {void} */\nexport function add_render_callback(fn) {\n\trender_callbacks.push(fn);\n}\n\n/** @returns {void} */\nexport function add_flush_callback(fn) {\n\tflush_callbacks.push(fn);\n}\n\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\n\nlet flushidx = 0; // Do *not* move this inside the flush() function\n\n/** @returns {void} */\nexport function flush() {\n\t// Do not reenter flush while dirty components are updated, as this can\n\t// result in an infinite loop. Instead, let the inner flush handle it.\n\t// Reentrancy is ok afterwards for bindings etc.\n\tif (flushidx !== 0) {\n\t\treturn;\n\t}\n\tconst saved_component = current_component;\n\tdo {\n\t\t// first, call beforeUpdate functions\n\t\t// and update components\n\t\ttry {\n\t\t\twhile (flushidx < dirty_components.length) {\n\t\t\t\tconst component = dirty_components[flushidx];\n\t\t\t\tflushidx++;\n\t\t\t\tset_current_component(component);\n\t\t\t\tupdate(component.$$);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// reset dirty state to not end up in a deadlocked state and then rethrow\n\t\t\tdirty_components.length = 0;\n\t\t\tflushidx = 0;\n\t\t\tthrow e;\n\t\t}\n\t\tset_current_component(null);\n\t\tdirty_components.length = 0;\n\t\tflushidx = 0;\n\t\twhile (binding_callbacks.length) binding_callbacks.pop()();\n\t\t// then, once components are updated, call\n\t\t// afterUpdate functions. This may cause\n\t\t// subsequent updates...\n\t\tfor (let i = 0; i < render_callbacks.length; i += 1) {\n\t\t\tconst callback = render_callbacks[i];\n\t\t\tif (!seen_callbacks.has(callback)) {\n\t\t\t\t// ...so guard against infinite loops\n\t\t\t\tseen_callbacks.add(callback);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t\trender_callbacks.length = 0;\n\t} while (dirty_components.length);\n\twhile (flush_callbacks.length) {\n\t\tflush_callbacks.pop()();\n\t}\n\tupdate_scheduled = false;\n\tseen_callbacks.clear();\n\tset_current_component(saved_component);\n}\n\n/** @returns {void} */\nfunction update($$) {\n\tif ($$.fragment !== null) {\n\t\t$$.update();\n\t\trun_all($$.before_update);\n\t\tconst dirty = $$.dirty;\n\t\t$$.dirty = [-1];\n\t\t$$.fragment && $$.fragment.p($$.ctx, dirty);\n\t\t$$.after_update.forEach(add_render_callback);\n\t}\n}\n\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function flush_render_callbacks(fns) {\n\tconst filtered = [];\n\tconst targets = [];\n\trender_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));\n\ttargets.forEach((c) => c());\n\trender_callbacks = filtered;\n}\n","import { identity as linear, is_function, noop, run_all } from './utils.js';\nimport { now } from './environment.js';\nimport { loop } from './loop.js';\nimport { create_rule, delete_rule } from './style_manager.js';\nimport { custom_event } from './dom.js';\nimport { add_render_callback } from './scheduler.js';\n\n/**\n * @type {Promise<void> | null}\n */\nlet promise;\n\n/**\n * @returns {Promise<void>}\n */\nfunction wait() {\n\tif (!promise) {\n\t\tpromise = Promise.resolve();\n\t\tpromise.then(() => {\n\t\t\tpromise = null;\n\t\t});\n\t}\n\treturn promise;\n}\n\n/**\n * @param {Element} node\n * @param {INTRO | OUTRO | boolean} direction\n * @param {'start' | 'end'} kind\n * @returns {void}\n */\nfunction dispatch(node, direction, kind) {\n\tnode.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\n\nconst outroing = new Set();\n\n/**\n * @type {Outro}\n */\nlet outros;\n\n/**\n * @returns {void} */\nexport function group_outros() {\n\toutros = {\n\t\tr: 0,\n\t\tc: [],\n\t\tp: outros // parent group\n\t};\n}\n\n/**\n * @returns {void} */\nexport function check_outros() {\n\tif (!outros.r) {\n\t\trun_all(outros.c);\n\t}\n\toutros = outros.p;\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} [local]\n * @returns {void}\n */\nexport function transition_in(block, local) {\n\tif (block && block.i) {\n\t\toutroing.delete(block);\n\t\tblock.i(local);\n\t}\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} local\n * @param {0 | 1} [detach]\n * @param {() => void} [callback]\n * @returns {void}\n */\nexport function transition_out(block, local, detach, callback) {\n\tif (block && block.o) {\n\t\tif (outroing.has(block)) return;\n\t\toutroing.add(block);\n\t\toutros.c.push(() => {\n\t\t\toutroing.delete(block);\n\t\t\tif (callback) {\n\t\t\t\tif (detach) block.d(1);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t\tblock.o(local);\n\t} else if (callback) {\n\t\tcallback();\n\t}\n}\n\n/**\n * @type {import('../transition/public.js').TransitionConfig}\n */\nconst null_transition = { duration: 0 };\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ start(): void; invalidate(): void; end(): void; }}\n */\nexport function create_in_transition(node, fn, params) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'in' };\n\tlet config = fn(node, params, options);\n\tlet running = false;\n\tlet animation_name;\n\tlet task;\n\tlet uid = 0;\n\n\t/**\n\t * @returns {void} */\n\tfunction cleanup() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\t\tif (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n\t\ttick(0, 1);\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tif (task) task.abort();\n\t\trunning = true;\n\t\tadd_render_callback(() => dispatch(node, true, 'start'));\n\t\ttask = loop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(1, 0);\n\t\t\t\t\tdispatch(node, true, 'end');\n\t\t\t\t\tcleanup();\n\t\t\t\t\treturn (running = false);\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\tlet started = false;\n\treturn {\n\t\tstart() {\n\t\t\tif (started) return;\n\t\t\tstarted = true;\n\t\t\tdelete_rule(node);\n\t\t\tif (is_function(config)) {\n\t\t\t\tconfig = config(options);\n\t\t\t\twait().then(go);\n\t\t\t} else {\n\t\t\t\tgo();\n\t\t\t}\n\t\t},\n\t\tinvalidate() {\n\t\t\tstarted = false;\n\t\t},\n\t\tend() {\n\t\t\tif (running) {\n\t\t\t\tcleanup();\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ end(reset: any): void; }}\n */\nexport function create_out_transition(node, fn, params) {\n\t/** @type {TransitionOptions} */\n\tconst options = { direction: 'out' };\n\tlet config = fn(node, params, options);\n\tlet running = true;\n\tlet animation_name;\n\tconst group = outros;\n\tgroup.r += 1;\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\tif (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tadd_render_callback(() => dispatch(node, false, 'start'));\n\n\t\tif ('inert' in node) {\n\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\tnode.inert = true;\n\t\t}\n\n\t\tloop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(0, 1);\n\t\t\t\t\tdispatch(node, false, 'end');\n\t\t\t\t\tif (!--group.r) {\n\t\t\t\t\t\t// this will result in `end()` being called,\n\t\t\t\t\t\t// so we don't need to clean up here\n\t\t\t\t\t\trun_all(group.c);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(1 - t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\n\tif (is_function(config)) {\n\t\twait().then(() => {\n\t\t\t// @ts-ignore\n\t\t\tconfig = config(options);\n\t\t\tgo();\n\t\t});\n\t} else {\n\t\tgo();\n\t}\n\n\treturn {\n\t\tend(reset) {\n\t\t\tif (reset && 'inert' in node) {\n\t\t\t\tnode.inert = original_inert_value;\n\t\t\t}\n\t\t\tif (reset && config.tick) {\n\t\t\t\tconfig.tick(1, 0);\n\t\t\t}\n\t\t\tif (running) {\n\t\t\t\tif (animation_name) delete_rule(node, animation_name);\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @param {boolean} intro\n * @returns {{ run(b: 0 | 1): void; end(): void; }}\n */\nexport function create_bidirectional_transition(node, fn, params, intro) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'both' };\n\tlet config = fn(node, params, options);\n\tlet t = intro ? 0 : 1;\n\n\t/**\n\t * @type {Program | null} */\n\tlet running_program = null;\n\n\t/**\n\t * @type {PendingProgram | null} */\n\tlet pending_program = null;\n\tlet animation_name = null;\n\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction clear_animation() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @param {PendingProgram} program\n\t * @param {number} duration\n\t * @returns {Program}\n\t */\n\tfunction init(program, duration) {\n\t\tconst d = /** @type {Program['d']} */ (program.b - t);\n\t\tduration *= Math.abs(d);\n\t\treturn {\n\t\t\ta: t,\n\t\t\tb: program.b,\n\t\t\td,\n\t\t\tduration,\n\t\t\tstart: program.start,\n\t\t\tend: program.start + duration,\n\t\t\tgroup: program.group\n\t\t};\n\t}\n\n\t/**\n\t * @param {INTRO | OUTRO} b\n\t * @returns {void}\n\t */\n\tfunction go(b) {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\t/**\n\t\t * @type {PendingProgram} */\n\t\tconst program = {\n\t\t\tstart: now() + delay,\n\t\t\tb\n\t\t};\n\n\t\tif (!b) {\n\t\t\t// @ts-ignore todo: improve typings\n\t\t\tprogram.group = outros;\n\t\t\toutros.r += 1;\n\t\t}\n\n\t\tif ('inert' in node) {\n\t\t\tif (b) {\n\t\t\t\tif (original_inert_value !== undefined) {\n\t\t\t\t\t// aborted/reversed outro  restore previous inert value\n\t\t\t\t\tnode.inert = original_inert_value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\t\tnode.inert = true;\n\t\t\t}\n\t\t}\n\n\t\tif (running_program || pending_program) {\n\t\t\tpending_program = program;\n\t\t} else {\n\t\t\t// if this is an intro, and there's a delay, we need to do\n\t\t\t// an initial tick and/or apply CSS animation immediately\n\t\t\tif (css) {\n\t\t\t\tclear_animation();\n\t\t\t\tanimation_name = create_rule(node, t, b, duration, delay, easing, css);\n\t\t\t}\n\t\t\tif (b) tick(0, 1);\n\t\t\trunning_program = init(program, duration);\n\t\t\tadd_render_callback(() => dispatch(node, b, 'start'));\n\t\t\tloop((now) => {\n\t\t\t\tif (pending_program && now > pending_program.start) {\n\t\t\t\t\trunning_program = init(pending_program, duration);\n\t\t\t\t\tpending_program = null;\n\t\t\t\t\tdispatch(node, running_program.b, 'start');\n\t\t\t\t\tif (css) {\n\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\tanimation_name = create_rule(\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\tt,\n\t\t\t\t\t\t\trunning_program.b,\n\t\t\t\t\t\t\trunning_program.duration,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\teasing,\n\t\t\t\t\t\t\tconfig.css\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (running_program) {\n\t\t\t\t\tif (now >= running_program.end) {\n\t\t\t\t\t\ttick((t = running_program.b), 1 - t);\n\t\t\t\t\t\tdispatch(node, running_program.b, 'end');\n\t\t\t\t\t\tif (!pending_program) {\n\t\t\t\t\t\t\t// we're done\n\t\t\t\t\t\t\tif (running_program.b) {\n\t\t\t\t\t\t\t\t// intro  we can tidy up immediately\n\t\t\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// outro  needs to be coordinated\n\t\t\t\t\t\t\t\tif (!--running_program.group.r) run_all(running_program.group.c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trunning_program = null;\n\t\t\t\t\t} else if (now >= running_program.start) {\n\t\t\t\t\t\tconst p = now - running_program.start;\n\t\t\t\t\t\tt = running_program.a + running_program.d * easing(p / running_program.duration);\n\t\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn !!(running_program || pending_program);\n\t\t\t});\n\t\t}\n\t}\n\treturn {\n\t\trun(b) {\n\t\t\tif (is_function(config)) {\n\t\t\t\twait().then(() => {\n\t\t\t\t\tconst opts = { direction: b ? 'in' : 'out' };\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconfig = config(opts);\n\t\t\t\t\tgo(b);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tgo(b);\n\t\t\t}\n\t\t},\n\t\tend() {\n\t\t\tclear_animation();\n\t\t\trunning_program = pending_program = null;\n\t\t}\n\t};\n}\n\n/** @typedef {1} INTRO */\n/** @typedef {0} OUTRO */\n/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */\n/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */\n\n/**\n * @typedef {Object} Outro\n * @property {number} r\n * @property {Function[]} c\n * @property {Object} p\n */\n\n/**\n * @typedef {Object} PendingProgram\n * @property {number} start\n * @property {INTRO|OUTRO} b\n * @property {Outro} [group]\n */\n\n/**\n * @typedef {Object} Program\n * @property {number} a\n * @property {INTRO|OUTRO} b\n * @property {1|-1} d\n * @property {number} duration\n * @property {number} start\n * @property {number} end\n * @property {Outro} [group]\n */\n","import {\n\tadd_render_callback,\n\tflush,\n\tflush_render_callbacks,\n\tschedule_update,\n\tdirty_components\n} from './scheduler.js';\nimport { current_component, set_current_component } from './lifecycle.js';\nimport { blank_object, is_empty, is_function, run, run_all, noop } from './utils.js';\nimport {\n\tchildren,\n\tdetach,\n\tstart_hydrating,\n\tend_hydrating,\n\tget_custom_elements_slots,\n\tinsert,\n\telement,\n\tattr\n} from './dom.js';\nimport { transition_in } from './transitions.js';\n\n/** @returns {void} */\nexport function bind(component, name, callback) {\n\tconst index = component.$$.props[name];\n\tif (index !== undefined) {\n\t\tcomponent.$$.bound[index] = callback;\n\t\tcallback(component.$$.ctx[index]);\n\t}\n}\n\n/** @returns {void} */\nexport function create_component(block) {\n\tblock && block.c();\n}\n\n/** @returns {void} */\nexport function claim_component(block, parent_nodes) {\n\tblock && block.l(parent_nodes);\n}\n\n/** @returns {void} */\nexport function mount_component(component, target, anchor) {\n\tconst { fragment, after_update } = component.$$;\n\tfragment && fragment.m(target, anchor);\n\t// onMount happens before the initial afterUpdate\n\tadd_render_callback(() => {\n\t\tconst new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n\t\t// if the component was destroyed immediately\n\t\t// it will update the `$$.on_destroy` reference to `null`.\n\t\t// the destructured on_destroy may still reference to the old array\n\t\tif (component.$$.on_destroy) {\n\t\t\tcomponent.$$.on_destroy.push(...new_on_destroy);\n\t\t} else {\n\t\t\t// Edge case - component was destroyed immediately,\n\t\t\t// most likely as a result of a binding initialising\n\t\t\trun_all(new_on_destroy);\n\t\t}\n\t\tcomponent.$$.on_mount = [];\n\t});\n\tafter_update.forEach(add_render_callback);\n}\n\n/** @returns {void} */\nexport function destroy_component(component, detaching) {\n\tconst $$ = component.$$;\n\tif ($$.fragment !== null) {\n\t\tflush_render_callbacks($$.after_update);\n\t\trun_all($$.on_destroy);\n\t\t$$.fragment && $$.fragment.d(detaching);\n\t\t// TODO null out other refs, including component.$$ (but need to\n\t\t// preserve final state?)\n\t\t$$.on_destroy = $$.fragment = null;\n\t\t$$.ctx = [];\n\t}\n}\n\n/** @returns {void} */\nfunction make_dirty(component, i) {\n\tif (component.$$.dirty[0] === -1) {\n\t\tdirty_components.push(component);\n\t\tschedule_update();\n\t\tcomponent.$$.dirty.fill(0);\n\t}\n\tcomponent.$$.dirty[(i / 31) | 0] |= 1 << i % 31;\n}\n\n// TODO: Document the other params\n/**\n * @param {SvelteComponent} component\n * @param {import('./public.js').ComponentConstructorOptions} options\n *\n * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.\n * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.\n * This will be the `add_css` function from the compiled component.\n *\n * @returns {void}\n */\nexport function init(\n\tcomponent,\n\toptions,\n\tinstance,\n\tcreate_fragment,\n\tnot_equal,\n\tprops,\n\tappend_styles = null,\n\tdirty = [-1]\n) {\n\tconst parent_component = current_component;\n\tset_current_component(component);\n\t/** @type {import('./private.js').T$$} */\n\tconst $$ = (component.$$ = {\n\t\tfragment: null,\n\t\tctx: [],\n\t\t// state\n\t\tprops,\n\t\tupdate: noop,\n\t\tnot_equal,\n\t\tbound: blank_object(),\n\t\t// lifecycle\n\t\ton_mount: [],\n\t\ton_destroy: [],\n\t\ton_disconnect: [],\n\t\tbefore_update: [],\n\t\tafter_update: [],\n\t\tcontext: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n\t\t// everything else\n\t\tcallbacks: blank_object(),\n\t\tdirty,\n\t\tskip_bound: false,\n\t\troot: options.target || parent_component.$$.root\n\t});\n\tappend_styles && append_styles($$.root);\n\tlet ready = false;\n\t$$.ctx = instance\n\t\t? instance(component, options.props || {}, (i, ret, ...rest) => {\n\t\t\t\tconst value = rest.length ? rest[0] : ret;\n\t\t\t\tif ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n\t\t\t\t\tif (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n\t\t\t\t\tif (ready) make_dirty(component, i);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t  })\n\t\t: [];\n\t$$.update();\n\tready = true;\n\trun_all($$.before_update);\n\t// `false` as a special case of no DOM component\n\t$$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\tif (options.target) {\n\t\tif (options.hydrate) {\n\t\t\tstart_hydrating();\n\t\t\t// TODO: what is the correct type here?\n\t\t\t// @ts-expect-error\n\t\t\tconst nodes = children(options.target);\n\t\t\t$$.fragment && $$.fragment.l(nodes);\n\t\t\tnodes.forEach(detach);\n\t\t} else {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\t$$.fragment && $$.fragment.c();\n\t\t}\n\t\tif (options.intro) transition_in(component.$$.fragment);\n\t\tmount_component(component, options.target, options.anchor);\n\t\tend_hydrating();\n\t\tflush();\n\t}\n\tset_current_component(parent_component);\n}\n\nexport let SvelteElement;\n\nif (typeof HTMLElement === 'function') {\n\tSvelteElement = class extends HTMLElement {\n\t\t/** The Svelte component constructor */\n\t\t$$ctor;\n\t\t/** Slots */\n\t\t$$s;\n\t\t/** The Svelte component instance */\n\t\t$$c;\n\t\t/** Whether or not the custom element is connected */\n\t\t$$cn = false;\n\t\t/** Component props data */\n\t\t$$d = {};\n\t\t/** `true` if currently in the process of reflecting component props back to attributes */\n\t\t$$r = false;\n\t\t/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n\t\t$$p_d = {};\n\t\t/** @type {Record<string, Function[]>} Event listeners */\n\t\t$$l = {};\n\t\t/** @type {Map<Function, Function>} Event listener unsubscribe functions */\n\t\t$$l_u = new Map();\n\n\t\tconstructor($$componentCtor, $$slots, use_shadow_dom) {\n\t\t\tsuper();\n\t\t\tthis.$$ctor = $$componentCtor;\n\t\t\tthis.$$s = $$slots;\n\t\t\tif (use_shadow_dom) {\n\t\t\t\tthis.attachShadow({ mode: 'open' });\n\t\t\t}\n\t\t}\n\n\t\taddEventListener(type, listener, options) {\n\t\t\t// We can't determine upfront if the event is a custom event or not, so we have to\n\t\t\t// listen to both. If someone uses a custom event with the same name as a regular\n\t\t\t// browser event, this fires twice - we can't avoid that.\n\t\t\tthis.$$l[type] = this.$$l[type] || [];\n\t\t\tthis.$$l[type].push(listener);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t}\n\t\t\tsuper.addEventListener(type, listener, options);\n\t\t}\n\n\t\tremoveEventListener(type, listener, options) {\n\t\t\tsuper.removeEventListener(type, listener, options);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$l_u.get(listener);\n\t\t\t\tif (unsub) {\n\t\t\t\t\tunsub();\n\t\t\t\t\tthis.$$l_u.delete(listener);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tasync connectedCallback() {\n\t\t\tthis.$$cn = true;\n\t\t\tif (!this.$$c) {\n\t\t\t\t// We wait one tick to let possible child slot elements be created/mounted\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tif (!this.$$cn) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfunction create_slot(name) {\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tlet node;\n\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\tc: function create() {\n\t\t\t\t\t\t\t\tnode = element('slot');\n\t\t\t\t\t\t\t\tif (name !== 'default') {\n\t\t\t\t\t\t\t\t\tattr(node, 'name', name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {HTMLElement} target\n\t\t\t\t\t\t\t * @param {HTMLElement} [anchor]\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tm: function mount(target, anchor) {\n\t\t\t\t\t\t\t\tinsert(target, node, anchor);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\td: function destroy(detaching) {\n\t\t\t\t\t\t\t\tif (detaching) {\n\t\t\t\t\t\t\t\t\tdetach(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tconst $$slots = {};\n\t\t\t\tconst existing_slots = get_custom_elements_slots(this);\n\t\t\t\tfor (const name of this.$$s) {\n\t\t\t\t\tif (name in existing_slots) {\n\t\t\t\t\t\t$$slots[name] = [create_slot(name)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const attribute of this.attributes) {\n\t\t\t\t\t// this.$$data takes precedence over this.attributes\n\t\t\t\t\tconst name = this.$$g_p(attribute.name);\n\t\t\t\t\tif (!(name in this.$$d)) {\n\t\t\t\t\t\tthis.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Port over props that were set programmatically before ce was initialized\n\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\tif (!(key in this.$$d) && this[key] !== undefined) {\n\t\t\t\t\t\tthis.$$d[key] = this[key]; // don't transform, these were set through JavaScript\n\t\t\t\t\t\tdelete this[key]; // remove the property that shadows the getter/setter\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$c = new this.$$ctor({\n\t\t\t\t\ttarget: this.shadowRoot || this,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...this.$$d,\n\t\t\t\t\t\t$$slots,\n\t\t\t\t\t\t$$scope: {\n\t\t\t\t\t\t\tctx: []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Reflect component props as attributes\n\t\t\t\tconst reflect_attributes = () => {\n\t\t\t\t\tthis.$$r = true;\n\t\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\t\tthis.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];\n\t\t\t\t\t\tif (this.$$p_d[key].reflect) {\n\t\t\t\t\t\t\tconst attribute_value = get_custom_element_value(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tthis.$$d[key],\n\t\t\t\t\t\t\t\tthis.$$p_d,\n\t\t\t\t\t\t\t\t'toAttribute'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (attribute_value == null) {\n\t\t\t\t\t\t\t\tthis.removeAttribute(this.$$p_d[key].attribute || key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.$$r = false;\n\t\t\t\t};\n\t\t\t\tthis.$$c.$$.after_update.push(reflect_attributes);\n\t\t\t\treflect_attributes(); // once initially because after_update is added too late for first render\n\n\t\t\t\tfor (const type in this.$$l) {\n\t\t\t\t\tfor (const listener of this.$$l[type]) {\n\t\t\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$l = {};\n\t\t\t}\n\t\t}\n\n\t\t// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n\t\t// and setting attributes through setAttribute etc, this is helpful\n\t\tattributeChangedCallback(attr, _oldValue, newValue) {\n\t\t\tif (this.$$r) return;\n\t\t\tattr = this.$$g_p(attr);\n\t\t\tthis.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\n\t\t\tthis.$$c?.$set({ [attr]: this.$$d[attr] });\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.$$cn = false;\n\t\t\t// In a microtask, because this could be a move within the DOM\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tif (!this.$$cn) {\n\t\t\t\t\tthis.$$c.$destroy();\n\t\t\t\t\tthis.$$c = undefined;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t$$g_p(attribute_name) {\n\t\t\treturn (\n\t\t\t\tObject.keys(this.$$p_d).find(\n\t\t\t\t\t(key) =>\n\t\t\t\t\t\tthis.$$p_d[key].attribute === attribute_name ||\n\t\t\t\t\t\t(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)\n\t\t\t\t) || attribute_name\n\t\t\t);\n\t\t}\n\t};\n}\n\n/**\n * @param {string} prop\n * @param {any} value\n * @param {Record<string, CustomElementPropDefinition>} props_definition\n * @param {'toAttribute' | 'toProp'} [transform]\n */\nfunction get_custom_element_value(prop, value, props_definition, transform) {\n\tconst type = props_definition[prop]?.type;\n\tvalue = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\n\tif (!transform || !props_definition[prop]) {\n\t\treturn value;\n\t} else if (transform === 'toAttribute') {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value == null ? null : JSON.stringify(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value ? '' : null;\n\t\t\tcase 'Number':\n\t\t\t\treturn value == null ? null : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value && JSON.parse(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value; // conversion already handled above\n\t\t\tcase 'Number':\n\t\t\t\treturn value != null ? +value : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t}\n}\n\n/**\n * @internal\n *\n * Turn a Svelte component into a custom element.\n * @param {import('./public.js').ComponentType} Component  A Svelte component constructor\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\n * @param {string[]} slots  The slots to create\n * @param {string[]} accessors  Other accessors besides the ones for props the component has\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\n */\nexport function create_custom_element(\n\tComponent,\n\tprops_definition,\n\tslots,\n\taccessors,\n\tuse_shadow_dom,\n\textend\n) {\n\tlet Class = class extends SvelteElement {\n\t\tconstructor() {\n\t\t\tsuper(Component, slots, use_shadow_dom);\n\t\t\tthis.$$p_d = props_definition;\n\t\t}\n\t\tstatic get observedAttributes() {\n\t\t\treturn Object.keys(props_definition).map((key) =>\n\t\t\t\t(props_definition[key].attribute || key).toLowerCase()\n\t\t\t);\n\t\t}\n\t};\n\tObject.keys(props_definition).forEach((prop) => {\n\t\tObject.defineProperty(Class.prototype, prop, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tvalue = get_custom_element_value(prop, value, props_definition);\n\t\t\t\tthis.$$d[prop] = value;\n\t\t\t\tthis.$$c?.$set({ [prop]: value });\n\t\t\t}\n\t\t});\n\t});\n\taccessors.forEach((accessor) => {\n\t\tObject.defineProperty(Class.prototype, accessor, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c?.[accessor];\n\t\t\t}\n\t\t});\n\t});\n\tif (extend) {\n\t\t// @ts-expect-error - assigning here is fine\n\t\tClass = extend(Class);\n\t}\n\tComponent.element = /** @type {any} */ (Class);\n\treturn Class;\n}\n\n/**\n * Base class for Svelte components. Used when dev=false.\n *\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n */\nexport class SvelteComponent {\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$ = undefined;\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$set = undefined;\n\n\t/** @returns {void} */\n\t$destroy() {\n\t\tdestroy_component(this, 1);\n\t\tthis.$destroy = noop;\n\t}\n\n\t/**\n\t * @template {Extract<keyof Events, string>} K\n\t * @param {K} type\n\t * @param {((e: Events[K]) => void) | null | undefined} callback\n\t * @returns {() => void}\n\t */\n\t$on(type, callback) {\n\t\tif (!is_function(callback)) {\n\t\t\treturn noop;\n\t\t}\n\t\tconst callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n\t\tcallbacks.push(callback);\n\t\treturn () => {\n\t\t\tconst index = callbacks.indexOf(callback);\n\t\t\tif (index !== -1) callbacks.splice(index, 1);\n\t\t};\n\t}\n\n\t/**\n\t * @param {Partial<Props>} props\n\t * @returns {void}\n\t */\n\t$set(props) {\n\t\tif (this.$$set && !is_empty(props)) {\n\t\t\tthis.$$.skip_bound = true;\n\t\t\tthis.$$set(props);\n\t\t\tthis.$$.skip_bound = false;\n\t\t}\n\t}\n}\n\n/**\n * @typedef {Object} CustomElementPropDefinition\n * @property {string} [attribute]\n * @property {boolean} [reflect]\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\n */\n","export namespace Events {\n  /**\n   * A message emitted from the micro frontend when a custom message is sent\n   */\n  export const CUSTOM_MESSAGE = 'custom-message';\n  /**\n   * A message emitted from the micro frontend when the context data is sent\n   */\n  export const GET_CONTEXT_REQUEST = 'get-context-request';\n  /**\n   * A message emitted from the micro frontend when a navigation request is sent\n   */\n  export const NAVIGATION_REQUEST = 'navigation-request';\n  /**\n   * A message emitted from the micro frontend when a request to show an alert is sent\n   */\n  export const ALERT_REQUEST = 'show-alert-request';\n  /**\n   * A message emitted from the micro frontend when a request to show an alert is sent\n   */\n  export const ALERT_CLOSED = 'close-alert-request';\n  /**\n   * A message emitted from the micro frontend when it is first initialized\n   */\n  export const INITIALIZED = 'initialized';\n  /**\n   * A message emitted from the micro frontend to request adding search parameters to the URL\n   */\n  export const ADD_SEARCH_PARAMS_REQUEST = 'add-search-params-request';\n  /**\n   * A message emitted from the micro frontend to request adding node parameters to the URL\n   */\n  export const ADD_NODE_PARAMS_REQUEST = 'add-node-params-request';\n  /**\n   * A message emitted from the micro frontend when a request to show a confirmation modal is sent\n   */\n  export const SHOW_CONFIRMATION_MODAL_REQUEST = 'show-confirmation-modal-request';\n  /**\n   * A message emitted from the micro frontend when a request to show a loading indicator is sent\n   */\n  export const SHOW_LOADING_INDICATOR_REQUEST = 'show-loading-indicator-request';\n  /**\n   * A message emitted from the micro frontend when a request to hide the loading indicator is sent\n   */\n  export const HIDE_LOADING_INDICATOR_REQUEST = 'hide-loading-indicator-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to set the current locale is sent\n   */\n  export const SET_CURRENT_LOCALE_REQUEST = 'set-current-locale-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to modify the local storage is sent\n   */\n  export const LOCAL_STORAGE_SET_REQUEST = 'set-storage-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to handle an error that happened during the runtime of the micro frontend is sent\n   */\n  export const RUNTIME_ERROR_HANDLING_REQUEST = 'runtime-error-handling-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to set the anchor of the URL is sent\n   */\n  export const SET_ANCHOR_LINK_REQUEST = 'set-anchor-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to set third-party cookies is sent\n   */\n  export const SET_THIRD_PARTY_COOKIES_REQUEST = 'set-third-party-cookies-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to navigate back is sent\n   */\n  export const BACK_NAVIGATION_REQUEST = 'navigate-back-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to receive the current app route is sent\n   */\n  export const GET_CURRENT_ROUTE_REQUEST = 'get-current-route-request';\n\n  /**\n   * A message emitted from the micro frontend to report that the navigation is completed is sent\n   */\n  export const NAVIGATION_COMPLETED_REPORT = 'report-navigation-completed-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to update the modal path parameters is sent\n   */\n  export const UPDATE_MODAL_PATH_DATA_REQUEST = 'update-modal-path-data-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to check on the validity of a path is sent\n   */\n  export const CHECK_PATH_EXISTS_REQUEST = 'check-path-exists-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to set the 'dirty status' (eg: avoid closing if unsaved changes) is sent\n   */\n  export const SET_DIRTY_STATUS_REQUEST = 'set-dirty-status-request';\n\n /**\n   * A message emitted from the micro frontend when a request to set the view group data\n   */\n export const SET_VIEW_GROUP_DATA_REQUEST = 'set-viewgroup-data-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to set the document title\n   */\n  export const SET_DOCUMENT_TITLE_REQUEST = 'set-document-title-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to open user settings \n   */\n  export const OPEN_USER_SETTINGS_REQUEST = 'open-user-settings-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to close user settings \n   */\n  export const CLOSE_USER_SETTINGS_REQUEST = 'close-user-settings-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to collapse left side navigation\n   */\n  export const COLLAPSE_LEFT_NAV_REQUEST = 'collapse-leftnav-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to remove the backdrop\n   */\n  export const UPDATE_TOP_NAVIGATION_REQUEST = 'update-top-navigation-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to remove the backdrop\n   */\n  export const PATH_EXISTS_REQUEST = 'path-exists-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to remove the backdrop\n   */\n  export const GO_BACK_REQUEST = 'go-back-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to remove the backdrop\n   */\n  export const HAS_BACK_REQUEST = 'has-back-request';\n\n  /**\n   * A message emitted from the micro frontend when a request to remove the backdrop\n   */\n  export const REMOVE_BACKDROP_REQUEST = 'remove-backdrop-request';\n}\n","export namespace LuigiInternalMessageID {\n  /**\n   * A message emmitted from the Microfrontend when a custom message is sent\n   */\n  export const CUSTOM_MESSAGE = 'custom';\n  /**\n   * A message emmitted from the Microfrontend when the context data is sent\n   */\n  export const GET_CONTEXT = 'luigi.get-context';\n  /**\n   * A message sent to the microfrontend from parent with the context upon init\n   */\n  export const SEND_CONTEXT_HANDSHAKE = 'luigi.init';\n\n  /**\n   * A message sent from the Microfrontend when the context data has been received properly\n   */\n  export const CONTEXT_RECEIVED = 'luigi.init.ok';\n  /**\n   * A message emmitted from the Microfrontend when a navigation request is sent\n   */\n  export const NAVIGATION_REQUEST = 'luigi.navigation.open';\n  /**\n   * A message emmitted from the Microfrontend when a request to show an alert is sent\n   */\n  export const ALERT_REQUEST = 'luigi.ux.alert.show';\n  /**\n   * A message sent to the microfrontend to notify closing of a particular alert\n   */\n  export const ALERT_CLOSED = 'luigi.ux.alert.hide';\n  /**\n   * A message emmitted from the Microfrontend when it is first initialized\n   */\n  export const INITIALIZED = 'luigi.init.ok';\n  /**\n   * A message emmitted from the Microfrontend to request adding search parameters to the URL\n   */\n  export const ADD_SEARCH_PARAMS_REQUEST = 'luigi.addSearchParams';\n  /**\n   * A message emmitted from the Microfrontend to request adding node parameters to the URL\n   */\n  export const ADD_NODE_PARAMS_REQUEST = 'luigi.addNodeParams';\n  /**\n   * A message emmitted from the Microfrontend when a request to show an confirmation modal is sent\n   */\n  export const SHOW_CONFIRMATION_MODAL_REQUEST = 'luigi.ux.confirmationModal.show';\n  /**\n   * A message emmitted from the Microfrontend when a request to show loading indicator is sent\n   */\n  export const SHOW_LOADING_INDICATOR_REQUEST = 'luigi.show-loading-indicator';\n  /**\n   * A message emmitted from the Microfrontend when a request to hide the loading indicator is sent\n   */\n  export const HIDE_LOADING_INDICATOR_REQUEST = 'luigi.hide-loading-indicator';\n\n  /**\n   * A message emmitted from the Microfrontend when a request to set the current locale is sent\n   */\n  export const SET_CURRENT_LOCALE_REQUEST = 'luigi.ux.set-current-locale';\n\n  /**\n   * A message emmitted from the Microfrontend when a request to modify the local storage is sent\n   */\n  export const LOCAL_STORAGE_SET_REQUEST = 'storage';\n\n  /**\n   * A message emmitted from the Microfrontend when a request to handle an error that happened during the runtime on the microfrontend is sent\n   */\n  export const RUNTIME_ERROR_HANDLING_REQUEST = 'luigi-runtime-error-handling';\n\n  /**\n   * A message emmitted from the Microfrontend when a request to set the anchor of the URL is sent\n   */\n  export const SET_ANCHOR_LINK_REQUEST = 'luigi.setAnchor';\n\n  /**\n   * A message emmitted from the Microfrontend when a request to set third party cookies is sent\n   */\n  export const SET_THIRD_PARTY_COOKIES_REQUEST = 'luigi.third-party-cookie';\n\n  /**\n   * A message emmitted from the Microfrontend when a request to navigate back is sent\n   */\n  export const BACK_NAVIGATION_REQUEST = 'luigi.navigation.back';\n\n  /**\n   * A message emmitted from the Microfrontend when a request to receive the current app route is sent\n   */\n  export const GET_CURRENT_ROUTE_REQUEST = 'luigi.navigation.currentRoute';\n\n  /**\n   * A message sent to the Microfrontend with the payload being the context being sent\n   */\n  export const SEND_CONTEXT_OBJECT = 'luigi.navigate';\n\n  /**\n   * A message emmitted from the Microfrontend to report that the navigation is completed is sent\n   */\n  export const NAVIGATION_COMPLETED_REPORT = 'luigi.navigate.ok';\n\n  /**\n   * A message emmitted from the Microfrontend when a request to update the modal path parameters is sent\n   */\n  export const UPDATE_MODAL_PATH_DATA_REQUEST = 'luigi.navigation.updateModalDataPath';\n\n  /**\n   * A message emmitted from the Microfrontend when a request to check on the validity of a path is sent\n   */\n  export const CHECK_PATH_EXISTS_REQUEST = 'luigi.navigation.pathExists';\n\n  /**\n   * A message emmitted from the Microfrontend when a request to set the 'dirty status' (ex: avoid closing if usaved changes) is sent\n   */\n  export const SET_DIRTY_STATUS_REQUEST = 'luigi.set-page-dirty';\n}\n","import { PUBLIC_VERSION } from '../../../shared/version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);\n","// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nexport const VERSION = '4.2.8';\nexport const PUBLIC_VERSION = '4';\n","export class GenericHelpersClass {\n  /**\n   * DUPLICATE: Duplicate of 'core/src/utilities/helpers/generic-helpers.js > isFunction'\n   * Keep one in the end\n   *\n   * Checks if input is a function.\n   * @param {any} functionToCheck function to check\n   * @returns {boolean}\n   */\n  isFunction(functionToCheck: any): boolean {\n    return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';\n  }\n  /**\n   * Checks if input is an object.\n   * @param objectToCheck mixed\n   * @returns {boolean}\n   */\n  isObject(objectToCheck) {\n    return !!(objectToCheck && typeof objectToCheck === 'object' && !Array.isArray(objectToCheck));\n  }\n\n  /**\n   * Checks whether web component is an attribute or property. In case of attribute, it returns the parsed value.\n   * @param {object | boolean | string} webcomponent value can either be an object, boolean or a stringified object, e.g webcomponent='{\"selfregistered\":\"true\"}'\n   * @returns {object | boolean} webcomponent returns the parsed webcomponent value.\n   */\n  checkWebcomponentValue(webcomponent: object | boolean | string): object | boolean {\n    if (typeof webcomponent === 'string') {\n      return JSON.parse(webcomponent);\n    } else if (typeof webcomponent === 'boolean' || typeof webcomponent === 'object') {\n      return webcomponent;\n    } else {\n      console.warn('Webcomponent value has a wrong type.')\n    }\n  }\n\n  /**\n  * Resolves the context to an object. If the context is a string, it attempts to parse\n  * it as JSON. If parsing fails JSON parse error will be thrown.\n  * @param {object | string} context - The context to be resolved.\n  * @returns {object} The resolved context as an object.\n  */\n  resolveContext(context: object | string): object {\n    return context\n      ? typeof context === 'string'\n        ? JSON.parse(context)\n        : context\n      : {};\n  }\n}\n\nexport const GenericHelperFunctions = new GenericHelpersClass();\n","import { Events } from '../constants/communication';\r\nimport { LuigiInternalMessageID } from '../constants/internal-communication';\r\nimport { GenericHelperFunctions } from '../utilities/helpers';\r\n\r\nexport class ContainerService {\r\n  /**\r\n   * Checks if the given HTML element is visible in the DOM by considering both\r\n   * its width/height and any client rectangles it may have.\r\n   *\r\n   * @param {HTMLElement} component - The HTML element to check for visibility.\r\n   * @returns {boolean} Returns true if the element is visible, otherwise false.\r\n   */\r\n  isVisible (component: HTMLElement): boolean {\r\n    return !!(component.offsetWidth || component.offsetHeight || component.getClientRects().length);\r\n  }\r\n\r\n  /**\r\n   * Sends a message to the iframe either with the custom keyword or any other message name\r\n   * @param iframeHandle the iframe to send the message to\r\n   * @param msg the message to be sent\r\n   * @param msgName the optional message name\r\n   */\r\n  sendCustomMessageToIframe (iframeHandle: any, msg: any, msgName?: string) {\r\n    const messageName = msgName || 'custom';\r\n    if (iframeHandle.iframe.contentWindow) {\r\n      const iframeUrl = new URL(iframeHandle.iframe.src);\r\n      messageName === 'custom'\r\n        ? iframeHandle.iframe.contentWindow.postMessage({ msg: messageName, data: msg }, iframeUrl.origin)\r\n        : iframeHandle.iframe.contentWindow.postMessage({ msg: messageName, ...msg }, iframeUrl.origin);\r\n    } else {\r\n      console.error('Message target could not be resolved');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dispatch an event to the given target container\r\n   * @param {string} msg the event message\r\n   * @param {HTMLElement} targetCnt the targeted HTML element onto which the event is dispatched\r\n   * @param {any} data custom data added to the event to be dispatched\r\n   * @param {Function} callback\r\n   * @param {string} callbackName\r\n   */\r\n  dispatch (msg: string, targetCnt: HTMLElement, data: any, callback?: Function, callbackName?: string): void {\r\n    const customEvent = new CustomEvent(msg, { detail: data });\r\n    if (callback && GenericHelperFunctions.isFunction(callback) && callbackName) {\r\n      (customEvent as any)[callbackName] = data => {\r\n        callback(data);\r\n      };\r\n    }\r\n    targetCnt.dispatchEvent(customEvent);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the target container based on the event source.\r\n   * \r\n   * @param event The event object representing the source of the container.\r\n    @returns {Object| undefined} The target container object or undefined if not found.\r\n   */\r\n  getTargetContainer (event) {\r\n    let cnt;\r\n    globalThis.__luigi_container_manager.container.forEach(element => {\r\n      if (element.iframeHandle?.iframe && element.iframeHandle.iframe.contentWindow === event.source) {\r\n        cnt = element;\r\n      }\r\n    });\r\n\r\n    return cnt;\r\n  }\r\n\r\n  /**\r\n   * Initializes the Luigi Container Manager responsible for managing communication\r\n   * between microfrontends and dispatching events accordingly. Also adds 'message' listener to the window object with \r\n   * the defined messageListener list\r\n   * @returns __luigi_container_manager which has the added container array and message listeners\r\n   */\r\n  getContainerManager () {\r\n    if (!globalThis.__luigi_container_manager) {\r\n      globalThis.__luigi_container_manager = {\r\n        container: [],\r\n        messageListener: event => {\r\n          // Handle incoming messages and dispatch events based on the message type\r\n          // (Custom messages, navigation requests, alert requests, etc.)\r\n          const targetCnt = this.getTargetContainer(event);\r\n          const target = targetCnt?.iframeHandle?.iframe?.contentWindow;\r\n          if (target && target === event.source) {\r\n            // messages emitted from microfrontends\r\n            const msg = event.data.msg;\r\n\r\n            // dispatch an event depending on message\r\n            switch (msg) {\r\n              case LuigiInternalMessageID.CUSTOM_MESSAGE:\r\n                {\r\n                  const evData = event.data.data;\r\n                  const id = evData.id;\r\n                  delete evData.id;\r\n                  this.dispatch(Events.CUSTOM_MESSAGE, targetCnt, {\r\n                    id: id,\r\n                    _metaData: {},\r\n                    data: evData\r\n                  });\r\n                }\r\n                break;\r\n              case LuigiInternalMessageID.GET_CONTEXT:\r\n                // Automatically send a luigi.init message to complete the initial handshake with the microfrontend\r\n                target.postMessage(\r\n                  {\r\n                    msg: LuigiInternalMessageID.SEND_CONTEXT_HANDSHAKE,\r\n                    context: targetCnt.context || {},\r\n                    internal: {}\r\n                  },\r\n                  '*'\r\n                );\r\n                break;\r\n              case LuigiInternalMessageID.NAVIGATION_REQUEST:\r\n                this.dispatch(Events.NAVIGATION_REQUEST, targetCnt, event.data.params);\r\n                break;\r\n              // TODO 1: handle alerts with ids on next iteration\r\n              case LuigiInternalMessageID.ALERT_REQUEST:\r\n                this.dispatch(Events.ALERT_REQUEST, targetCnt, event);\r\n                break;\r\n              case LuigiInternalMessageID.INITIALIZED:\r\n                this.dispatch(Events.INITIALIZED, targetCnt, event.data.params);\r\n                break;\r\n              case LuigiInternalMessageID.ADD_SEARCH_PARAMS_REQUEST:\r\n                this.dispatch(Events.ADD_SEARCH_PARAMS_REQUEST, targetCnt, {\r\n                  data: event.data.data,\r\n                  keepBrowserHistory: event.data.keepBrowserHistory\r\n                });\r\n                break;\r\n              case LuigiInternalMessageID.ADD_NODE_PARAMS_REQUEST:\r\n                this.dispatch(Events.ADD_NODE_PARAMS_REQUEST, targetCnt, {\r\n                  data: event.data.data,\r\n                  keepBrowserHistory: event.data.keepBrowserHistory\r\n                });\r\n                break;\r\n              case LuigiInternalMessageID.SHOW_CONFIRMATION_MODAL_REQUEST:\r\n                this.dispatch(Events.SHOW_CONFIRMATION_MODAL_REQUEST, targetCnt, event.data.data);\r\n                break;\r\n              case LuigiInternalMessageID.SHOW_LOADING_INDICATOR_REQUEST:\r\n                this.dispatch(Events.SHOW_LOADING_INDICATOR_REQUEST, targetCnt, event);\r\n                break;\r\n              case LuigiInternalMessageID.HIDE_LOADING_INDICATOR_REQUEST:\r\n                this.dispatch(Events.HIDE_LOADING_INDICATOR_REQUEST, targetCnt, event);\r\n                break;\r\n              case LuigiInternalMessageID.SET_CURRENT_LOCALE_REQUEST:\r\n                this.dispatch(Events.SET_CURRENT_LOCALE_REQUEST, targetCnt, event);\r\n                break;\r\n              case LuigiInternalMessageID.LOCAL_STORAGE_SET_REQUEST:\r\n                this.dispatch(Events.LOCAL_STORAGE_SET_REQUEST, targetCnt, event);\r\n                break;\r\n              case LuigiInternalMessageID.RUNTIME_ERROR_HANDLING_REQUEST:\r\n                this.dispatch(Events.RUNTIME_ERROR_HANDLING_REQUEST, targetCnt, event);\r\n                break;\r\n              case LuigiInternalMessageID.SET_ANCHOR_LINK_REQUEST:\r\n                this.dispatch(Events.SET_ANCHOR_LINK_REQUEST, targetCnt, event);\r\n                break;\r\n              case LuigiInternalMessageID.SET_THIRD_PARTY_COOKIES_REQUEST:\r\n                this.dispatch(Events.SET_THIRD_PARTY_COOKIES_REQUEST, targetCnt, event);\r\n                break;\r\n              case LuigiInternalMessageID.BACK_NAVIGATION_REQUEST:\r\n                this.dispatch(Events.BACK_NAVIGATION_REQUEST, targetCnt, event);\r\n                break;\r\n              case LuigiInternalMessageID.GET_CURRENT_ROUTE_REQUEST:\r\n                this.dispatch(Events.GET_CURRENT_ROUTE_REQUEST, targetCnt, event);\r\n                break;\r\n              // TODO: discuss if actually needed as the only scenario is when microfrontend initially starts\r\n              case LuigiInternalMessageID.NAVIGATION_COMPLETED_REPORT:\r\n                this.dispatch(Events.NAVIGATION_COMPLETED_REPORT, targetCnt, event);\r\n                break;\r\n              case LuigiInternalMessageID.UPDATE_MODAL_PATH_DATA_REQUEST:\r\n                this.dispatch(Events.UPDATE_MODAL_PATH_DATA_REQUEST, targetCnt, event);\r\n                break;\r\n              case LuigiInternalMessageID.CHECK_PATH_EXISTS_REQUEST:\r\n                this.dispatch(Events.CHECK_PATH_EXISTS_REQUEST, targetCnt, event);\r\n                break;\r\n              case LuigiInternalMessageID.SET_DIRTY_STATUS_REQUEST:\r\n                this.dispatch(Events.SET_DIRTY_STATUS_REQUEST, targetCnt, event);\r\n                break;\r\n              default:\r\n                console.warn('Functionality not yet implemented: ', msg);\r\n                break;\r\n            }\r\n          }\r\n        }\r\n      };\r\n      window.addEventListener('message', globalThis.__luigi_container_manager.messageListener);\r\n    }\r\n    return globalThis.__luigi_container_manager;\r\n  }\r\n\r\n  /**\r\n   * Adds thisComponent's object reference the the __luigi_container_manager container list\r\n   *\r\n   * @param {HTMLElement} thisComponent - The HTML element that represents the current rendered container (thisComponent)\r\n   */\r\n  registerContainer (thisComponent: HTMLElement): void {\r\n    this.getContainerManager().container.push(thisComponent);\r\n  }\r\n}\r\n\r\nexport const containerService = new ContainerService();\r\n","/**\r\n * Default compound renderer.\r\n */\r\nexport class DefaultCompoundRenderer {\r\n  rendererObject: any;\r\n  config: any;\r\n\r\n  constructor (rendererObj?: any) {\r\n    if (rendererObj) {\r\n      this.rendererObject = rendererObj;\r\n      this.config = rendererObj.config || {};\r\n    } else {\r\n      this.config = {};\r\n    }\r\n  }\r\n\r\n  createCompoundContainer () {\r\n    return document.createElement('div');\r\n  }\r\n\r\n  createCompoundItemContainer (layoutConfig?: any): HTMLDivElement {\r\n    return document.createElement('div');\r\n  }\r\n\r\n  attachCompoundItem (compoundCnt, compoundItemCnt): void {\r\n    compoundCnt.appendChild(compoundItemCnt);\r\n  }\r\n}\r\n\r\n/**\r\n * Compound Renderer for custom rendering as defined in luigi config.\r\n */\r\nexport class CustomCompoundRenderer extends DefaultCompoundRenderer {\r\n  superRenderer: DefaultCompoundRenderer;\r\n\r\n  constructor (rendererObj) {\r\n    super(rendererObj || { use: {} });\r\n    if (rendererObj && rendererObj.use && rendererObj.use.extends) {\r\n      this.superRenderer = resolveRenderer({\r\n        use: rendererObj.use.extends,\r\n        config: rendererObj.config\r\n      });\r\n    }\r\n  }\r\n\r\n  createCompoundContainer (): HTMLDivElement {\r\n    if (this.rendererObject.use.createCompoundContainer) {\r\n      return this.rendererObject.use.createCompoundContainer(this.config, this.superRenderer);\r\n    } else if (this.superRenderer) {\r\n      return this.superRenderer.createCompoundContainer();\r\n    }\r\n    return super.createCompoundContainer();\r\n  }\r\n\r\n  createCompoundItemContainer (layoutConfig): HTMLDivElement {\r\n    if (this.rendererObject.use.createCompoundItemContainer) {\r\n      return this.rendererObject.use.createCompoundItemContainer(layoutConfig, this.config, this.superRenderer);\r\n    } else if (this.superRenderer) {\r\n      return this.superRenderer.createCompoundItemContainer(layoutConfig);\r\n    }\r\n    return super.createCompoundItemContainer(layoutConfig);\r\n  }\r\n\r\n  attachCompoundItem (compoundCnt, compoundItemCnt): void {\r\n    if (this.rendererObject.use.attachCompoundItem) {\r\n      this.rendererObject.use.attachCompoundItem(compoundCnt, compoundItemCnt, this.superRenderer);\r\n    } else if (this.superRenderer) {\r\n      this.superRenderer.attachCompoundItem(compoundCnt, compoundItemCnt);\r\n    } else {\r\n      super.attachCompoundItem(compoundCnt, compoundItemCnt);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Compound Renderer for a css grid compound view.\r\n */\r\nexport class GridCompoundRenderer extends DefaultCompoundRenderer {\r\n  createCompoundContainer () {\r\n    const containerClass = '__lui_compound_' + new Date().getTime();\r\n    const compoundCnt = document.createElement('div');\r\n    compoundCnt.classList.add(containerClass);\r\n    let mediaQueries = '';\r\n\r\n    if (this.config.layouts) {\r\n      this.config.layouts.forEach(el => {\r\n        if (el.minWidth || el.maxWidth) {\r\n          let mq = '@media only screen ';\r\n          if (el.minWidth != null) {\r\n            mq += `and (min-width: ${el.minWidth}px) `;\r\n          }\r\n          if (el.maxWidth != null) {\r\n            mq += `and (max-width: ${el.maxWidth}px) `;\r\n          }\r\n\r\n          mq += `{\r\n            .${containerClass} {\r\n              grid-template-columns: ${el.columns || 'auto'};\r\n              grid-template-rows: ${el.rows || 'auto'};\r\n              grid-gap: ${el.gap || '0'};\r\n            }\r\n          }\r\n          `;\r\n          mediaQueries += mq;\r\n        }\r\n      });\r\n    }\r\n\r\n    compoundCnt.innerHTML = /* html */ `\r\n        <style scoped>\r\n          .${containerClass} {\r\n            display: grid;\r\n            grid-template-columns: ${this.config.columns || 'auto'};\r\n            grid-template-rows: ${this.config.rows || 'auto'};\r\n            grid-gap: ${this.config.gap || '0'};\r\n            min-height: ${this.config.minHeight || 'auto'};\r\n          }\r\n          ${mediaQueries}\r\n        </style>\r\n    `;\r\n    return compoundCnt;\r\n  }\r\n\r\n  createCompoundItemContainer (layoutConfig): HTMLDivElement {\r\n    const config = layoutConfig || {};\r\n    const compoundItemCnt = document.createElement('div');\r\n    compoundItemCnt.setAttribute('style', `grid-row: ${config.row || 'auto'}; grid-column: ${config.column || 'auto'}`);\r\n    return compoundItemCnt;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the compound renderer class for a given config.\r\n * If no specific one is found, {DefaultCompoundRenderer} is returned.\r\n *\r\n * @param {*} rendererConfig the renderer config object defined in luigi config\r\n */\r\nexport const resolveRenderer = rendererConfig => {\r\n  const rendererDef = rendererConfig.use;\r\n  if (!rendererDef) {\r\n    return new DefaultCompoundRenderer(rendererConfig);\r\n  } else if (rendererDef === 'grid') {\r\n    return new GridCompoundRenderer(rendererConfig);\r\n  } else if (\r\n    rendererDef.createCompoundContainer ||\r\n    rendererDef.createCompoundItemContainer ||\r\n    rendererDef.attachCompoundItem\r\n  ) {\r\n    return new CustomCompoundRenderer(rendererConfig);\r\n  }\r\n  return new DefaultCompoundRenderer(rendererConfig);\r\n};\r\n\r\n/**\r\n * Registers event listeners defined at the navNode.\r\n *\r\n * @param {*} eventbusListeners a map of event listener arrays with event id as key\r\n * @param {*} navNode the web component node configuration object\r\n * @param {*} nodeId the web component node id\r\n * @param {*} wcElement the web component element - optional\r\n */\r\nexport const registerEventListeners = (eventbusListeners, navNode, nodeId: string, wcElement?) => {\r\n  if (navNode?.eventListeners) {\r\n    navNode.eventListeners.forEach(el => {\r\n      const evID = el.source + '.' + el.name;\r\n      const listenerList = eventbusListeners[evID];\r\n      const listenerInfo = {\r\n        wcElementId: nodeId,\r\n        wcElement: wcElement,\r\n        action: el.action,\r\n        converter: el.dataConverter\r\n      };\r\n\r\n      if (listenerList) {\r\n        listenerList.push(listenerInfo);\r\n      } else {\r\n        eventbusListeners[evID] = [listenerInfo];\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Desanitization of an object\r\n * @param {Object} paramsMap\r\n * @returns\r\n */\r\nexport const deSanitizeParamsMap = paramsMap => {\r\n  return Object.entries(paramsMap).reduce((sanitizedMap, paramPair) => {\r\n    sanitizedMap[deSanitizeParam(paramPair[0])] = deSanitizeParam(paramPair[1]);\r\n    return sanitizedMap;\r\n  }, {});\r\n};\r\n\r\nfunction deSanitizeParam (param: any) {\r\n  const desani = (String as any)(param)\r\n    .replaceAll('&lt;', '<')\r\n    .replaceAll('&gt;', '>')\r\n    .replaceAll('&quot;', '\"')\r\n    .replaceAll('&#39;', \"'\")\r\n    .replaceAll('&sol;', '/');\r\n  return desani;\r\n}\r\n","/* eslint no-prototype-builtins: 0 */\r\nimport {\r\n  DefaultCompoundRenderer,\r\n  resolveRenderer,\r\n  registerEventListeners,\r\n  deSanitizeParamsMap\r\n} from './web-component-helpers';\r\nimport { ContainerService } from './container.service';\r\nimport { Events } from '../constants/communication';\r\n\r\n/** Methods for dealing with web components based micro frontend handling */\r\nexport class WebComponentService {\r\n  containerService: ContainerService;\r\n  thisComponent: any;\r\n\r\n  constructor() {\r\n    this.containerService = new ContainerService();\r\n  }\r\n\r\n  dynamicImport(viewUrl: string) {\r\n    // Object.freeze() used as potential marker for bundlers other than webpack\r\n    return Object.freeze(import(/* webpackIgnore: true */ viewUrl));\r\n  }\r\n\r\n  processViewUrl(viewUrl: string, data?: any): string {\r\n    return viewUrl;\r\n  }\r\n\r\n  /** \r\n   * Attaches a web component with tagname wc_id and adds it to wcItemContainer,\r\n   * if attached to wc_container\r\n   * \r\n   * @param wc_id a tagname that is used when creating the web component element\r\n   * @param wcItemPlaceholder placeholder for web component container\r\n   * @param wc_container web component container element\r\n   * @param ctx context to be passed to the web component\r\n   * @param viewUrl url to render content from\r\n   * @param nodeId refers to an attribute of the web component to be identified from the rest\r\n   * @param isCompoundChild defines if rendered mf is a compound child or not\r\n   */\r\n  attachWC(\r\n    wc_id: string,\r\n    wcItemPlaceholder: HTMLDivElement,\r\n    wc_container,\r\n    ctx,\r\n    viewUrl: string,\r\n    nodeId: string,\r\n    isCompoundChild?: boolean\r\n  ) {\r\n    if (wc_container && wc_container.contains(wcItemPlaceholder)) {\r\n      const wc = document.createElement(wc_id);\r\n      if (nodeId) {\r\n        wc.setAttribute('nodeId', nodeId);\r\n      }\r\n\r\n      this.initWC(wc, wc_id, wc_container, viewUrl, ctx, nodeId, isCompoundChild);\r\n      wc_container.replaceChild(wc, wcItemPlaceholder);\r\n      if (wc_container._luigi_node) {\r\n        wc_container._luigi_mfe_webcomponent = wc;\r\n      }\r\n      wc_container.dispatchEvent(new Event('wc_ready'));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Function that uses the current instance of the containerService to dispatch a Luigi event to the current instance of the container\r\n   * that is 'thisComponent'\r\n   * @param msg the message to be delivered\r\n   * @param data the data to be sent\r\n   * @param callback the callback function to be called\r\n   */\r\n  dispatchLuigiEvent(msg: string, data: any, callback?: Function) {\r\n    this.containerService.dispatch(msg, this.thisComponent, data, callback);\r\n  }\r\n\r\n  /**\r\n   * This function is used to create the Luigi Client API for the web-component-based micro frontend.\r\n   * As the function expands with more functionality, it might be moved to a separate class.\r\n   * \r\n   * The client API here should be a reflection of the Core WC Client api from core/src/services/web-components.js\r\n   * \r\n   * @param eventBusElement the event bus to be used for cross web component communication, i.e.: for compound micro frontends container scenario\r\n   * @param nodeId refers to an attribute of the web component to be identified from the rest\r\n   * @param wc_id a tagname that is used when creating the web component element\r\n   * @param component \r\n   * @param isCompoundChild defines if rendered mf is a compound child or not\r\n   * @returns an object with the Luigi Client API\r\n   */\r\n  createClientAPI(eventBusElement, nodeId: string, wc_id: string, component: HTMLElement, isCompoundChild?: boolean) {\r\n    return {\r\n      linkManager: () => {\r\n        let fromContext = null;\r\n        let fromClosestContext = false;\r\n        let fromVirtualTreeRoot = false;\r\n        let nodeParams = {};\r\n\r\n        const linkManagerInstance = {\r\n          navigate: (route , settings = {})=> {\r\n            const options = { fromContext, fromClosestContext, fromVirtualTreeRoot, nodeParams, ...settings };\r\n            this.dispatchLuigiEvent(Events.NAVIGATION_REQUEST, { link: route , ...options});\r\n          },\r\n          fromClosestContext: () => {\r\n            fromClosestContext = true;\r\n            return linkManagerInstance;\r\n          },\r\n          fromContext: (navigationContext) => {\r\n            fromContext = navigationContext;\r\n            return linkManagerInstance;\r\n          },\r\n          fromVirtualTreeRoot: () => {\r\n            fromVirtualTreeRoot = true;\r\n            return linkManagerInstance;\r\n          },         \r\n          withParams: (params) => {\r\n            nodeParams = params;\r\n            return linkManagerInstance;\r\n          },\r\n          updateTopNavigation: (): void => {\r\n            this.dispatchLuigiEvent(Events.UPDATE_TOP_NAVIGATION_REQUEST, {});\r\n          },\r\n          pathExists: () => {\r\n            return new Promise((resolve, reject) => {\r\n              this.containerService.dispatch(Events.PATH_EXISTS_REQUEST, this.thisComponent, {}, (exists)=>{\r\n              if (exists) {\r\n                  resolve(true)\r\n                }  else {\r\n                  reject(false);\r\n                }\r\n              }, 'callback');\r\n            })\r\n          },          \r\n          openAsDrawer: (route, drawerSettings = {}) => {\r\n            linkManagerInstance.navigate(route, {drawer: drawerSettings})\r\n          },\r\n          openAsModal: (route, modalSettings = {}) => {\r\n            linkManagerInstance.navigate(route, {modal: modalSettings})\r\n          },\r\n          openAsSplitView: (route, splitViewSettings = {}) => {\r\n            linkManagerInstance.navigate(route, {splitView: splitViewSettings})\r\n          },          \r\n          goBack: (goBackContext) => {\r\n            this.dispatchLuigiEvent(Events.GO_BACK_REQUEST, goBackContext);\r\n          },\r\n          hasBack: () => {\r\n            return false;\r\n          }, \r\n        };\r\n        return linkManagerInstance;\r\n      },\r\n      uxManager: () => {\r\n        return {\r\n          showAlert: alertSettings => {\r\n            this.dispatchLuigiEvent(Events.ALERT_REQUEST, alertSettings);\r\n          },\r\n          showConfirmationModal: async settings => {\r\n            return new Promise((resolve, reject) => {\r\n              this.dispatchLuigiEvent(Events.SHOW_CONFIRMATION_MODAL_REQUEST, settings, data => {\r\n                if (data) {\r\n                  resolve(data);\r\n                } else {\r\n                  reject(new Error('No data'));\r\n                }\r\n              });\r\n            });\r\n          },\r\n          getCurrentTheme: () : string | undefined  => {\r\n            return this.thisComponent.theme;\r\n          },\r\n          closeUserSettings: () => {\r\n            this.dispatchLuigiEvent(Events.CLOSE_USER_SETTINGS_REQUEST, this.thisComponent.userSettings);\r\n          },          \r\n          openUserSettings: () => {\r\n            this.dispatchLuigiEvent(Events.OPEN_USER_SETTINGS_REQUEST, this.thisComponent.userSettings);\r\n          },\r\n          collapseLeftSideNav:() => {\r\n            this.dispatchLuigiEvent(Events.COLLAPSE_LEFT_NAV_REQUEST, {});\r\n          },\r\n          getDirtyStatus: () => {\r\n            return this.thisComponent.dirtyStatus || false;\r\n          },\r\n          getDocumentTitle: () => {\r\n            return this.thisComponent.documentTitle;\r\n          },\r\n          setDocumentTitle: (title) => {\r\n            this.dispatchLuigiEvent(Events.SET_DOCUMENT_TITLE_REQUEST, title);\r\n          },\r\n          removeBackdrop:() => {\r\n            this.dispatchLuigiEvent(Events.REMOVE_BACKDROP_REQUEST, {});\r\n          },\r\n          hideAppLoadingIndicator:() => {\r\n            this.dispatchLuigiEvent(Events.HIDE_LOADING_INDICATOR_REQUEST, {});\r\n          },\r\n        };\r\n      },\r\n      getCurrentLocale: () : string | undefined =>  {\r\n        return this.thisComponent.locale;\r\n      },\r\n      getActiveFeatureToggles: (): string[] => {\r\n        return this.thisComponent.activeFeatureToggleList || [];\r\n      },\r\n      publishEvent: ev => {\r\n        if (eventBusElement && eventBusElement.eventBus) {\r\n          eventBusElement.eventBus.onPublishEvent(ev, nodeId, wc_id);\r\n        }\r\n        const payload = {\r\n          id: ev.type,\r\n          _metaData: {\r\n            nodeId,\r\n            wc_id,\r\n            src: component\r\n          },\r\n          data: ev.detail\r\n        };\r\n        this.dispatchLuigiEvent(Events.CUSTOM_MESSAGE, payload);\r\n      },\r\n      luigiClientInit: () => {\r\n        this.dispatchLuigiEvent(Events.INITIALIZED, {});\r\n      },\r\n      addNodeParams: (params, keepBrowserHistory) => {\r\n        if (isCompoundChild) {\r\n          return;\r\n        }\r\n        this.dispatchLuigiEvent(Events.ADD_NODE_PARAMS_REQUEST, { params, keepBrowserHistory });\r\n      },\r\n      getNodeParams: (shouldDesanitise: boolean): Object  => {\r\n        if (isCompoundChild) {\r\n          return {};\r\n        }\r\n        if (shouldDesanitise) {\r\n          return deSanitizeParamsMap(this.thisComponent.nodeParams)\r\n        }\r\n        return this.thisComponent.nodeParams || {};\r\n      },\r\n      setAnchor: anchor => {\r\n        if (isCompoundChild) {\r\n          return;\r\n        }\r\n        this.dispatchLuigiEvent(Events.SET_ANCHOR_LINK_REQUEST, anchor);\r\n      },\r\n      getAnchor: (): string  => {\r\n        return this.thisComponent.anchor || '';\r\n      },\r\n      getCoreSearchParams: (): Object => {\r\n        return this.thisComponent.searchParams || {};\r\n      },\r\n      getPathParams: (): Object => {\r\n        return this.thisComponent.pathParams || {};\r\n      },\r\n      getClientPermissions: (): Object  => {\r\n        return this.thisComponent.clientPermissions || {};\r\n      },\r\n      getUserSettings: (): Object => {\r\n        return this.thisComponent.userSettings || {};\r\n      },\r\n      setViewGroupData: (data) => {\r\n        this.dispatchLuigiEvent(Events.SET_VIEW_GROUP_DATA_REQUEST, data);\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Attaches Client Api to web component \r\n   * if __postProcess defined allow for custom setting of clientApi when developers want to decide how to add it to their mf \r\n   * otherwise just attach it to the wc webcomponent alongside the context directly.\r\n   * \r\n   * @param wc web component to attach to\r\n   * @param wc_id a tagname that is used when creating the web component element\r\n   * @param eventBusElement the event bus to be used for cross web component communication, i.e.: for compound micro frontends container scenario\r\n   * @param viewUrl url to render content from\r\n   * @param ctx context to be passed to the web component\r\n   * @param nodeId refers to an attribute of the web component to be identified from the rest\r\n   * @param isCompoundChild defines if rendered mf is a compound child or not\r\n   */\r\n  initWC(wc: HTMLElement | any, wc_id, eventBusElement, viewUrl: string, ctx, nodeId: string, isCompoundChild?: boolean) {\r\n    const clientAPI = this.createClientAPI(eventBusElement, nodeId, wc_id, wc, isCompoundChild);\r\n\r\n    if (wc.__postProcess) {\r\n      const url =\r\n        new URL(document.baseURI).origin === new URL(viewUrl, document.baseURI).origin // TODO: check if needed\r\n          ? new URL('./', new URL(viewUrl, document.baseURI))\r\n          : new URL('./', viewUrl);\r\n      wc.__postProcess(ctx, clientAPI, url.origin + url.pathname);\r\n    } else {\r\n      wc.context = ctx;\r\n      wc.LuigiClient = clientAPI;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates a unique web component id (tagname) based on the viewUrl\r\n   * returns a string that can be used as part of a tagname, only alphanumeric\r\n   * characters and no whitespaces.\r\n   */\r\n  generateWCId(viewUrl: string) {\r\n    let charRep = '';\r\n    const normalizedViewUrl = new URL(viewUrl, encodeURI(location.href)).href;\r\n    for (let i = 0; i < normalizedViewUrl.length; i++) {\r\n      charRep += normalizedViewUrl.charCodeAt(i).toString(16);\r\n    }\r\n    return 'luigi-wc-' + charRep;\r\n  }\r\n\r\n  /**\r\n   * Does a module import from viewUrl and defines a new web component\r\n   * with the default export of the module or the first export extending HTMLElement if no default is\r\n   * specified.\r\n   * @param viewUrl url to render content from\r\n   * @param wc_id a tagname that is used when creating the web component element\r\n   * @returns a promise that gets resolved after successfull import\r\n   */\r\n  registerWCFromUrl(viewUrl: string, wc_id: string) {\r\n    const i18nViewUrl = this.processViewUrl(viewUrl);\r\n    return new Promise((resolve, reject) => {\r\n      if (this.checkWCUrl(i18nViewUrl)) {\r\n        this.dynamicImport(i18nViewUrl)\r\n          .then(module => {\r\n            try {\r\n              if (!window.customElements.get(wc_id)) {\r\n                let cmpClazz = module.default;\r\n                if (!HTMLElement.isPrototypeOf(cmpClazz)) {\r\n                  const props = Object.keys(module);\r\n                  for (let i = 0; i < props.length; i++) {\r\n                    cmpClazz = module[props[i]];\r\n                    if (HTMLElement.isPrototypeOf(cmpClazz)) {\r\n                      break;\r\n                    }\r\n                  }\r\n                }\r\n                window.customElements.define(wc_id, cmpClazz);\r\n              }\r\n              resolve(1);\r\n            } catch (err) {\r\n              reject(err);\r\n            }\r\n          })\r\n          .catch(err => {\r\n            reject(err);\r\n          });\r\n      } else {\r\n        const message = `Error: View URL '${i18nViewUrl}' not allowed to be included`;\r\n        reject(message);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handles the import of self registered web component bundles, i.e. the web component\r\n   * is added to the customElements registry by the bundle code rather than by luigi.\r\n   *\r\n   * @param {*} node the corresponding navigation node\r\n   * @param {*} viewUrl the source of the wc bundle\r\n   * @param {*} onload callback function executed after script attached and loaded\r\n   */\r\n  includeSelfRegisteredWCFromUrl(node, viewUrl, onload) {\r\n    if (this.checkWCUrl(viewUrl)) {\r\n      /** Append reg function to luigi object if not present */\r\n      if (!this.containerService.getContainerManager()._registerWebcomponent) {\r\n        this.containerService.getContainerManager()._registerWebcomponent = (srcString, el) => {\r\n          window.customElements.define(this.generateWCId(srcString), el);\r\n        };\r\n      }\r\n      // @ts-ignore\r\n      if (!window.Luigi) {\r\n        // @ts-ignore\r\n        window.Luigi = {};\r\n        // @ts-ignore\r\n        if (!window.Luigi._registerWebcomponent) {\r\n          // @ts-ignore\r\n          window.Luigi._registerWebcomponent = (src, element) => {\r\n            this.containerService.getContainerManager()._registerWebcomponent(src, element);\r\n          }\r\n        }\r\n      }\r\n      const scriptTag = document.createElement('script');\r\n      scriptTag.setAttribute('src', viewUrl);\r\n      if (node.webcomponent.type === 'module') {\r\n        scriptTag.setAttribute('type', 'module');\r\n      }\r\n      scriptTag.setAttribute('defer', 'true');\r\n      scriptTag.addEventListener('load', () => {\r\n        onload();\r\n      });\r\n      document.body.appendChild(scriptTag);\r\n    } else {\r\n      console.warn(`View URL '${viewUrl}' not allowed to be included`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if a url is allowed to be included, based on 'navigation.validWebcomponentUrls' in luigi config.\r\n   * Returns true, if allowed.\r\n   *\r\n   * @param {*} url the url string to check\r\n   */\r\n  checkWCUrl(url: string) {\r\n    // if (url.indexOf('://') > 0 || url.trim().indexOf('//') === 0) {\r\n    //   const ur = new URL(url);\r\n    //   if (ur.host === window.location.host) {\r\n    //     return true; // same host is okay\r\n    //   }\r\n\r\n    //   const valids = LuigiConfig.getConfigValue('navigation.validWebcomponentUrls');\r\n    //   if (valids && valids.length > 0) {\r\n    //     for (let el of valids) {\r\n    //       try {\r\n    //         if (new RegExp(el).test(url)) {\r\n    //           return true;\r\n    //         }\r\n    //       } catch (e) {\r\n    //         console.error(e);\r\n    //       }\r\n    //     }\r\n    //   }\r\n    //   return false;\r\n    // }\r\n    // relative URL is okay\r\n    // if (url === 'test.js') {\r\n    //   return false;\r\n    // }\r\n    return true;\r\n  }\r\n\r\n  /** \r\n   * Adds a web component defined by viewUrl to the wc_container and sets the node context.\r\n   * If the web component is not defined yet, it gets imported.\r\n   * \r\n   * @param viewUrl url to render content from\r\n   * @param wc_container web component container element\r\n   * @param context luigi context\r\n   * @param node node to operate on\r\n   * @param nodeId id identifying the node\r\n   * @param isCompoundChild defines if rendered mf is a compound child or not\r\n   */\r\n  renderWebComponent(\r\n    viewUrl: string,\r\n    wc_container: HTMLElement | any,\r\n    context: any,\r\n    node: any,\r\n    nodeId?: any,\r\n    isCompoundChild?: boolean\r\n  ) {\r\n    const i18nViewUrl = this.processViewUrl(viewUrl, { context });\r\n    const wc_id = node?.webcomponent?.tagName || this.generateWCId(i18nViewUrl);\r\n    const wcItemPlaceholder = document.createElement('div');\r\n    wc_container.appendChild(wcItemPlaceholder);\r\n    wc_container._luigi_node = node;\r\n\r\n    if (window.customElements.get(wc_id)) {\r\n      this.attachWC(wc_id, wcItemPlaceholder, wc_container, context, i18nViewUrl, nodeId, isCompoundChild);\r\n    } else {\r\n      /** Custom import function, if defined */\r\n      if ((window as any).luigiWCFn) {\r\n        (window as any).luigiWCFn(i18nViewUrl, wc_id, wcItemPlaceholder, () => {\r\n          this.attachWC(wc_id, wcItemPlaceholder, wc_container, context, i18nViewUrl, nodeId, isCompoundChild);\r\n        });\r\n      } else if (node.webcomponent && node.webcomponent.selfRegistered) {\r\n        this.includeSelfRegisteredWCFromUrl(node, i18nViewUrl, () => {\r\n          this.attachWC(wc_id, wcItemPlaceholder, wc_container, context, i18nViewUrl, nodeId, isCompoundChild);\r\n        });\r\n      } else {\r\n        this.registerWCFromUrl(i18nViewUrl, wc_id)\r\n          .then(() => {\r\n            this.attachWC(wc_id, wcItemPlaceholder, wc_container, context, i18nViewUrl, nodeId, isCompoundChild);\r\n          })\r\n          .catch(error => {\r\n            console.warn('ERROR =>', error);\r\n            // dispatch an error event to be handled core side\r\n            this.containerService.dispatch(Events.RUNTIME_ERROR_HANDLING_REQUEST, this.thisComponent, error);\r\n          });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a compound container according to the given renderer.\r\n   * Returns a promise that gets resolved with the created container DOM element.\r\n   *\r\n   * @param {DefaultCompoundRenderer} renderer\r\n   */\r\n  createCompoundContainerAsync(renderer: any, ctx: any, navNode: any): Promise<HTMLElement> {\r\n    return new Promise((resolve, reject) => {\r\n      if (renderer.viewUrl) {\r\n        try {\r\n          const wc_id = navNode?.webcomponent?.tagName || this.generateWCId(renderer.viewUrl);\r\n          if (navNode.webcomponent && navNode.webcomponent.selfRegistered) {\r\n            this.includeSelfRegisteredWCFromUrl(navNode, renderer.viewUrl, () => {\r\n              const wc = document.createElement(wc_id);\r\n              this.initWC(wc, wc_id, wc, renderer.viewUrl, ctx, '_root');\r\n              resolve(wc);\r\n            });\r\n          } else {\r\n            this.registerWCFromUrl(renderer.viewUrl, wc_id)\r\n              .then(() => {\r\n                const wc = document.createElement(wc_id);\r\n                this.initWC(wc, wc_id, wc, renderer.viewUrl, ctx, '_root');\r\n                resolve(wc);\r\n              })\r\n              .catch(error => {\r\n                console.warn('Error: ', error);\r\n                // dispatch an error event to be handled core side\r\n                this.containerService.dispatch(Events.RUNTIME_ERROR_HANDLING_REQUEST, this.thisComponent, error);\r\n              });\r\n          }\r\n        } catch (error) {\r\n          reject(error);\r\n        }\r\n      } else {\r\n        resolve(renderer.createCompoundContainer());\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Responsible for rendering web component compounds based on a renderer or a nesting\r\n   * micro frontend.\r\n   *\r\n   * @param {*} navNode the navigation node defining the compound\r\n   * @param {HTMLElement} wc_container the web component container dom element\r\n   * @param {*} context the luigi node context\r\n   */\r\n  renderWebComponentCompound(navNode, wc_container: HTMLElement, context) {\r\n    let renderer;\r\n    if (navNode.webcomponent && navNode.viewUrl) {\r\n      renderer = new DefaultCompoundRenderer();\r\n      renderer.viewUrl = this.processViewUrl(navNode.viewUrl, { context });\r\n      renderer.createCompoundItemContainer = layoutConfig => {\r\n        const cnt = document.createElement('div');\r\n        if (layoutConfig && layoutConfig.slot) {\r\n          cnt.setAttribute('slot', layoutConfig.slot);\r\n        }\r\n        return cnt;\r\n      };\r\n    } else if (navNode.compound?.renderer) {\r\n      renderer = resolveRenderer(navNode.compound.renderer);\r\n    }\r\n\r\n    renderer = renderer || new DefaultCompoundRenderer();\r\n    return new Promise(resolve => {\r\n      this.createCompoundContainerAsync(renderer, context, navNode)\r\n        .then((compoundCnt: HTMLElement) => {\r\n          (wc_container as any)._luigi_mfe_webcomponent = compoundCnt;\r\n          (wc_container as any)._luigi_node = navNode;\r\n          const ebListeners = {};\r\n          (compoundCnt as any).eventBus = {\r\n            listeners: ebListeners,\r\n            onPublishEvent: (event, srcNodeId, wcId) => {\r\n              const listeners = ebListeners[srcNodeId + '.' + event.type] || [];\r\n              listeners.push(...(ebListeners['*.' + event.type] || []));\r\n\r\n              listeners.forEach(listenerInfo => {\r\n                const target =\r\n                  listenerInfo.wcElement || compoundCnt.querySelector('[nodeId=' + listenerInfo.wcElementId + ']');\r\n                if (target) {\r\n                  target.dispatchEvent(\r\n                    new CustomEvent(listenerInfo.action, {\r\n                      detail: listenerInfo.converter ? listenerInfo.converter(event.detail) : event.detail\r\n                    })\r\n                  );\r\n                } else {\r\n                  console.debug('Could not find event target', listenerInfo);\r\n                }\r\n              });\r\n            }\r\n          };\r\n          navNode.compound?.children.forEach((wc, index) => {\r\n            const ctx = { ...context, ...wc.context };\r\n            const compoundItemCnt = renderer.createCompoundItemContainer(wc.layoutConfig);\r\n\r\n            compoundItemCnt.eventBus = (compoundCnt as any).eventBus;\r\n            renderer.attachCompoundItem(compoundCnt, compoundItemCnt);\r\n\r\n            const nodeId = wc.id || 'gen_' + index;\r\n            this.renderWebComponent(wc.viewUrl, compoundItemCnt, ctx, wc, nodeId, true);\r\n            registerEventListeners(ebListeners, wc, nodeId);\r\n          });\r\n          wc_container.appendChild(compoundCnt);\r\n          // listener for nesting wc\r\n          registerEventListeners(ebListeners, navNode.compound, '_root', compoundCnt);\r\n          resolve(compoundCnt);\r\n        })\r\n        .catch(error => {\r\n          // dispatch an error event to be handled core sid\r\n          console.warn('Error: ', error);\r\n          this.containerService.dispatch(Events.RUNTIME_ERROR_HANDLING_REQUEST, this.thisComponent, error);\r\n        });\r\n    });\r\n  }\r\n}\r\n","import { LuigiInternalMessageID } from '../constants/internal-communication';\nimport { containerService } from '../services/container.service';\n\nexport class ContainerAPIFunctions {\n  /**\n   * Updates the context of the microfrontend by sending a message to the iframe or webcomponent that sets the context of the microfrontend\n   * @param contextObj The context data\n   * @param internal internal luigi legacy data\n   * @param iframeHandle a reference to the iframe that is needed to send a message to it internally\n   */\n  updateContext = (contextObj: any, internal?: any, iframeHandle?: any) => {\n    if (iframeHandle) {\n      const internalParameter = internal || {};\n      containerService.sendCustomMessageToIframe(\n        iframeHandle,\n        {\n          context: contextObj,\n          internal: internalParameter,\n          // set withoutSync to true for the container case to avoid browser history changes from luigi client\n          withoutSync: true\n        },\n        LuigiInternalMessageID.SEND_CONTEXT_OBJECT\n      );\n    } else {\n      console.warn('Attempting to update context on inexisting iframe');\n    }\n  };\n\n  /**\n   * Send a custom message to the referenced iframe or web component\n   * @param id a string containing the message id\n   * @param mainComponent a reference to the web component to be affected\n   * @param isWebcomponent predicate showing if currently referencing a web component or not\n   * @param iframeHandle a reference to the iframe to be affected\n   * @param data data to be sent alongside the custom message\n   */\n  sendCustomMessage = (id: string, mainComponent: any, isWebcomponent: boolean, iframeHandle: any, data?: any) => {\n    if (isWebcomponent && (mainComponent as any)._luigi_mfe_webcomponent) {\n      containerService.dispatch(id, (mainComponent as any)._luigi_mfe_webcomponent, data);\n    } else {\n      const msg = { ...data };\n      if (msg.id) {\n        console.warn('Property \"id\" is reserved and can not be used in custom message data');\n      }\n      msg.id = id;\n      containerService.sendCustomMessageToIframe(iframeHandle, msg);\n    }\n  };\n\n  /**\n   * Send a message to the microfrontend notifying the alert has been closed\n   * @param id the id of the alert being closed\n   * @param dismissKey the dismiss key being sent if any\n   * @param iframeHandle the handle of the iframe to send the message to\n   */\n  closeAlert(id: any, dismissKey: any, iframeHandle: any) {\n    containerService.sendCustomMessageToIframe(iframeHandle, { id, dismissKey }, LuigiInternalMessageID.ALERT_CLOSED);\n  }\n}\n\nexport const ContainerAPI = new ContainerAPIFunctions();\n","/**\n * Retrieves the allow rules for iframes and modifies them according to w3c standard conditions.\n * @param {string[]} allowRules - An array of allow rules.\n * @returns {string|undefined} The modified allow rules joined as a single string, or undefined if allowRules is falsy.\n */\nexport const getAllowRules = (allowRules: string[]) => {\n    if (!allowRules) return undefined;\n    const rules = allowRules;\n    rules.forEach((rule, index) => {\n        rules[index] = rule + (rule.indexOf(';') != -1 ? '' : ';');\n        rules[index] = (allowRules[index] as any).replaceAll('\"', \"'\");\n    });\n    return rules.join(' ');\n};","<svelte:options\n  customElement={{\n    tag: null,\n    props: {\n      viewurl: { type: 'String', reflect: false, attribute: 'viewurl' },\n      deferInit: { type: 'Boolean', attribute: 'defer-init' },\n      context: { type: 'String', reflect: false, attribute: 'context' },\n      label: { type: 'String', reflect: false, attribute: 'label' },\n      webcomponent: {\n        type: 'String',\n        reflect: false,\n        attribute: 'webcomponent',\n      },\n      locale: { type: 'String', reflect: false, attribute: 'locale' },\n      theme: { type: 'String', reflect: false, attribute: 'theme' },\n      activeFeatureToggleList: {\n        type: 'Array',\n        reflect: false,\n        attribute: 'active-feature-toggle-list',\n      },\n      skipInitCheck: {\n        type: 'Boolean',\n        reflect: false,\n        attribute: 'skip-init-check',\n      },\n      nodeParams: { type: 'Object', reflect: false, attribute: 'node-params' },\n      userSettings: {\n        type: 'Object',\n        reflect: false,\n        attribute: 'user-settings',\n      },\n      anchor: { type: 'String', reflect: false, attribute: 'anchor' },\n      searchParams: {\n        type: 'Object',\n        reflect: false,\n        attribute: 'search-params',\n      },\n      pathParams: { type: 'Object', reflect: false, attribute: 'path-params' },\n      clientPermissions: {\n        type: 'Object',\n        reflect: false,\n        attribute: 'client-permissions',\n      },\n      dirtyStatus: { type: 'Boolean', reflect: false, attribute: 'dirty-status'},\n      hasBack: { type: 'Boolean', reflect: false, attribute: 'has-back'},\n      documentTitle: {type: 'String', reflect: false, attribute: 'document-title'},\n      allowRules: {\n        type: 'Array',\n        reflect: false,\n        attribute: 'allow-rules',\n      },\n      sandboxRules: {\n        type: 'Array',\n        reflect: false,\n        attribute: 'sandbox-rules',\n      }\n    },\n    extend: (customElementConstructor) => {\n      let notInitFn = (name) => {\n        return () =>\n          console.warn(\n            name +\n              \" can't be called on luigi-container before its micro frontend is attached to the DOM.\",\n          );\n      };\n      return class extends customElementConstructor {\n        sendCustomMessage = notInitFn('sendCustomMessage');\n        updateContext = notInitFn('updateContext');\n        closeAlert = notInitFn('closeAlert');\n        attributeChangedCallback(name, oldValue, newValue) {\n          if (this.containerInitialized && name === 'context') {\n            this.updateContext(JSON.parse(newValue));\n          }\n        }\n      };\n    },\n  }}\n/>\n\n<script lang=\"ts\">\n  import { onMount, onDestroy } from 'svelte';\n  import { containerService } from './services/container.service';\n  import { WebComponentService } from './services/webcomponents.service';\n  import { ContainerAPI } from './api/container-api';\n  import { Events } from './constants/communication';\n  import { GenericHelperFunctions } from './utilities/helpers';\n  import { getAllowRules } from './services/iframe-helpers';\n\n  export let viewurl: string;\n  export let context: string;\n  export let label: string;\n  export let webcomponent: any;\n  export let deferInit: boolean;\n  export let locale: string;\n  export let theme: string;\n  export let activeFeatureToggleList: string[];\n  export let skipInitCheck: boolean;\n  export let nodeParams: any;\n  export let searchParams: any;\n  export let pathParams: any;\n  export let clientPermissions: any;\n  export let dirtyStatus: boolean;\n  export let hasBack: boolean;\n  export let documentTitle: string;\n  export let allowRules: string[];\n  export let sandboxRules: string[];\n\n\n  export let userSettings: any;\n  export let anchor: string;\n\n  const iframeHandle:\n    | {\n        iframe: HTMLIFrameElement;\n      }\n    | any = {};\n  let mainComponent: HTMLElement;\n\n  let containerInitialized = false;\n\n  const webcomponentService = new WebComponentService();\n\n  // Only needed for get rid of \"unused export property\" svelte compiler warnings\n  export const unwarn = () => {\n    return (\n      locale &&\n      theme &&\n      activeFeatureToggleList &&\n      nodeParams &&\n      searchParams &&\n      pathParams &&\n      clientPermissions &&\n      userSettings &&\n      anchor &&\n      dirtyStatus &&\n      hasBack &&\n      documentTitle &&\n      allowRules &&\n      sandboxRules\n    );\n  };\n\n  const initialize = (thisComponent: any) => {\n    if (!containerInitialized) {\n      thisComponent.sendCustomMessage = (id: string, data?: any) => {\n        ContainerAPI.sendCustomMessage(\n          id,\n          mainComponent,\n          !!webcomponent,\n          iframeHandle,\n          data,\n        );\n      };\n\n      thisComponent.updateContext = (contextObj: any, internal?: any) => {\n        if (webcomponent) {\n          mainComponent._luigi_mfe_webcomponent.context = contextObj;\n        } else {\n          ContainerAPI.updateContext(contextObj, internal, iframeHandle);\n        }\n      };\n\n      thisComponent.closeAlert = (id: any, dismissKey: any) => {\n        ContainerAPI.closeAlert(id, dismissKey, iframeHandle);\n      };\n\n      containerService.registerContainer(thisComponent);\n      webcomponentService.thisComponent = thisComponent;\n\n      const ctx = GenericHelperFunctions.resolveContext(context);\n      if (webcomponent && webcomponent != \"false\") {\n        mainComponent.innerHTML = '';\n        const webComponentValue =\n          GenericHelperFunctions.checkWebcomponentValue(webcomponent);\n        webcomponentService.renderWebComponent(\n          viewurl,\n          mainComponent,\n          ctx,\n          typeof webComponentValue === 'object'\n            ? { webcomponent: webComponentValue }\n            : {},\n        );\n      }\n      if (skipInitCheck) {\n        thisComponent.initialized = true;\n        setTimeout(() => {\n          webcomponentService.dispatchLuigiEvent(Events.INITIALIZED, {});\n        });\n      } else if (webcomponent) {\n        mainComponent.addEventListener('wc_ready', () => {\n          if (\n            !(mainComponent as any)._luigi_mfe_webcomponent\n              ?.deferLuigiClientWCInit\n          ) {\n            thisComponent.initialized = true;\n            webcomponentService.dispatchLuigiEvent(Events.INITIALIZED, {});\n          }\n        });\n      }\n      containerInitialized = true;\n      thisComponent.containerInitialized = true;\n    }\n  };\n\n  onMount(async () => {\n    const thisComponent: any = (mainComponent.getRootNode() as ShadowRoot).host;\n    thisComponent.iframeHandle = iframeHandle;\n    thisComponent.init = () => {\n      initialize(thisComponent);\n    };\n    if (!deferInit) {\n      initialize(thisComponent);\n    }\n  });\n\n  onDestroy(async () => {});\n</script>\n\n<main\n  bind:this={mainComponent}\n  class={webcomponent ? undefined : 'lui-isolated'}\n>\n  {#if containerInitialized}\n    {#if !webcomponent || webcomponent === \"false\"}\n      <iframe\n        bind:this={iframeHandle.iframe}\n        src={viewurl}\n        title={label}\n        allow={getAllowRules(allowRules)}\n        sandbox={sandboxRules ? sandboxRules.join(' ') : undefined}\n      />\n    {/if}\n  {/if}\n</main>\n\n<style>\n  main,\n  iframe {\n    width: 100%;\n    height: 100%;\n    border: none;\n  }\n\n  main.lui-isolated {\n    line-height: 0;\n  }\n</style>\n","<svelte:options\n  customElement={{\n    tag: null,\n    props: {\n      viewurl: { type: 'String', reflect: false, attribute: 'viewurl' },\n      deferInit: { type: 'Boolean', attribute: 'defer-init' },\n      context: { type: 'String', reflect: false, attribute: 'context' },\n      compoundConfig: {\n        type: 'Object',\n        reflect: false,\n        attribute: 'compound-config',\n      },\n      nodeParams: { type: 'Object', reflect: false, attribute: 'node-params' },\n      userSettings: {\n        type: 'Object',\n        reflect: false,\n        attribute: 'user-settings',\n      },\n      anchor: { type: 'String', reflect: false, attribute: 'anchor' },\n      searchParams: {\n        type: 'Object',\n        reflect: false,\n        attribute: 'search-params',\n      },\n      pathParams: { type: 'Object', reflect: false, attribute: 'path-params' },\n      clientPermissions: {\n        type: 'Object',\n        reflect: false,\n        attribute: 'client-permissions',\n      },\n      dirtyStatus: { type: 'Boolean', reflect: false, attribute: 'dirty-status'},\n      hasBack: { type: 'Boolean', reflect: false, attribute: 'has-back'},\n      documentTitle: {type: 'String', reflect: false, attribute: 'document-title'},\n    },\n    extend: (customElementConstructor) => {\n      let notInitFn = (name) => {\n        return () =>\n          console.warn(\n            name +\n              \" can't be called on luigi-container before its micro frontend is attached to the DOM.\",\n          );\n      };\n      return class extends customElementConstructor {\n        updateContext = notInitFn('updateContext');\n        attributeChangedCallback(name, oldValue, newValue) {\n          if (this.containerInitialized && name === 'context') {\n            this.updateContext(JSON.parse(newValue));\n          }\n        }\n      };\n    },\n  }}\n/>\n\n<script lang=\"ts\">\n  import { onMount } from 'svelte';\n  import { ContainerService } from './services/container.service';\n  import { WebComponentService } from './services/webcomponents.service';\n  import { Events } from './constants/communication';\n  import { GenericHelperFunctions } from './utilities/helpers';\n\n  export let viewurl: string;\n  export let webcomponent: any;\n  export let context: string;\n  export let deferInit: boolean;\n  export let compoundConfig: any;\n  export let nodeParams: any;\n  export let searchParams: any;\n  export let pathParams: any;\n  export let clientPermissions: any;\n  export let userSettings: any;\n  export let anchor: string;\n  export let dirtyStatus: boolean;\n  export let hasBack: boolean;\n  export let documentTitle: string;\n\n  let containerInitialized = false;\n  let mainComponent: HTMLElement;\n  let eventBusElement: HTMLElement;\n\n  const containerService = new ContainerService();\n  const webcomponentService = new WebComponentService();\n\n  // Only needed for get rid of \"unused export property\" svelte compiler warnings\n  export const unwarn = () => {\n    return (\n      nodeParams &&\n      searchParams &&\n      pathParams &&\n      clientPermissions &&\n      userSettings &&\n      anchor && \n      dirtyStatus &&\n      hasBack &&\n      documentTitle\n    );\n  };\n\n  const initialize = (thisComponent: any) => {\n    if (!compoundConfig || containerInitialized) {\n      return;\n    }\n    thisComponent.updateContext = (contextObj: any, internal?: any) => {\n      mainComponent._luigi_mfe_webcomponent.context = contextObj;\n    };\n    const ctx = GenericHelperFunctions.resolveContext(context);\n    deferInit = false;\n\n    const node = {\n      compound: compoundConfig,\n      viewUrl: viewurl,\n      webcomponent:\n        GenericHelperFunctions.checkWebcomponentValue(webcomponent) || true,\n    }; // TODO: fill with sth\n    webcomponentService\n      .renderWebComponentCompound(node, mainComponent, ctx)\n      .then((compCnt) => {\n        eventBusElement = compCnt as HTMLElement;\n        if (thisComponent.hasAttribute('skip-init-check') || !node.viewUrl) {\n          thisComponent.initialized = true;\n          setTimeout(() => {\n            webcomponentService.dispatchLuigiEvent(Events.INITIALIZED, {});\n          });\n        } else if (\n          (eventBusElement as any).LuigiClient &&\n          !(eventBusElement as any).deferLuigiClientWCInit\n        ) {\n          thisComponent.initialized = true;\n          webcomponentService.dispatchLuigiEvent(Events.INITIALIZED, {});\n        }\n      });\n    containerInitialized = true;\n    thisComponent.containerInitialized = true;\n  };\n\n  onMount(async () => {\n    const thisComponent: any = (mainComponent.getRootNode() as ShadowRoot).host;\n\n    thisComponent.init = () => {\n      initialize(thisComponent);\n    };\n    if (!deferInit) {\n      initialize(thisComponent);\n    }\n\n    containerService.registerContainer(thisComponent);\n    webcomponentService.thisComponent = thisComponent;\n  });\n</script>\n\n<main bind:this={mainComponent} />\n\n<style>\n  main {\n    width: 100%;\n    height: 100%;\n    border: none;\n  }\n</style>\n","import LuigiContainer from './LuigiContainer.svelte';\nimport LuigiCompoundContainer from './LuigiCompoundContainer.svelte';\nimport { Events } from './constants/communication';\nexport { default as LuigiContainer } from './LuigiContainer.svelte';\nexport { default as LuigiCompoundContainer } from './LuigiCompoundContainer.svelte';\nexport type { PathExistsEvent } from './constants/event-type';\n\nexport default Events;\n\nif (!customElements.get('luigi-container')) {\n  customElements.define('luigi-container', (LuigiContainer as any).element);\n}\n\nif (!customElements.get('luigi-compound-container')) {\n  customElements.define('luigi-compound-container', (LuigiCompoundContainer as any).element);\n}\n"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","src_url_equal_anchor","current_component","src_url_equal","element_src","url","document","createElement","href","null_to_empty","value","append_styles","target","style_sheet_id","styles","append_styles_to","node","root","getRootNode","ownerDocument","host","get_root_for_style","getElementById","style","element","id","textContent","appendChild","append","head","sheet","append_stylesheet","insert","anchor","insertBefore","detach","parentNode","removeChild","name","empty","data","createTextNode","attr","attribute","removeAttribute","getAttribute","setAttribute","set_current_component","component","get_current_component","Error","onMount","$$","on_mount","push","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","seen_callbacks","Set","flushidx","flush","saved_component","length","update","e","pop","i","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","destroy_component","detaching","filtered","targets","c","indexOf","flush_render_callbacks","on_destroy","d","make_dirty","then","fill","init","options","instance","create_fragment","not_equal","props","parent_component","bound","on_disconnect","context","Map","callbacks","skip_bound","ready","ret","rest","hydrate","nodes","Array","from","childNodes","children","l","intro","block","delete","local","m","new_on_destroy","map","filter","mount_component","SvelteElement","get_custom_element_value","prop","props_definition","transform","type","JSON","stringify","parse","create_custom_element","Component","slots","accessors","use_shadow_dom","extend","Class","constructor","super","this","$$p_d","observedAttributes","keys","key","toLowerCase","defineProperty","prototype","get","$$c","$$d","set","$set","accessor","HTMLElement","$$ctor","$$s","$$cn","$$r","$$l","$$l_u","$$componentCtor","$$slots","attachShadow","mode","addEventListener","listener","unsub","$on","removeEventListener","async","create_slot","existing_slots","result","slot","get_custom_elements_slots","attributes","$$g_p","undefined","shadowRoot","$$scope","reflect_attributes","reflect","attribute_value","attributeChangedCallback","_oldValue","newValue","disconnectedCallback","$destroy","attribute_name","find","SvelteComponent","$$set","index","splice","obj","Events","LuigiInternalMessageID","window","__svelte","v","CUSTOM_MESSAGE","GET_CONTEXT_REQUEST","NAVIGATION_REQUEST","ALERT_REQUEST","ALERT_CLOSED","INITIALIZED","ADD_SEARCH_PARAMS_REQUEST","ADD_NODE_PARAMS_REQUEST","SHOW_CONFIRMATION_MODAL_REQUEST","SHOW_LOADING_INDICATOR_REQUEST","HIDE_LOADING_INDICATOR_REQUEST","SET_CURRENT_LOCALE_REQUEST","LOCAL_STORAGE_SET_REQUEST","RUNTIME_ERROR_HANDLING_REQUEST","SET_ANCHOR_LINK_REQUEST","SET_THIRD_PARTY_COOKIES_REQUEST","BACK_NAVIGATION_REQUEST","GET_CURRENT_ROUTE_REQUEST","NAVIGATION_COMPLETED_REPORT","UPDATE_MODAL_PATH_DATA_REQUEST","CHECK_PATH_EXISTS_REQUEST","SET_DIRTY_STATUS_REQUEST","SET_VIEW_GROUP_DATA_REQUEST","SET_DOCUMENT_TITLE_REQUEST","OPEN_USER_SETTINGS_REQUEST","CLOSE_USER_SETTINGS_REQUEST","COLLAPSE_LEFT_NAV_REQUEST","UPDATE_TOP_NAVIGATION_REQUEST","PATH_EXISTS_REQUEST","GO_BACK_REQUEST","HAS_BACK_REQUEST","REMOVE_BACKDROP_REQUEST","GET_CONTEXT","SEND_CONTEXT_HANDSHAKE","CONTEXT_RECEIVED","SEND_CONTEXT_OBJECT","GenericHelperFunctions","isFunction","functionToCheck","toString","call","isObject","objectToCheck","isArray","checkWebcomponentValue","webcomponent","console","warn","resolveContext","ContainerService","isVisible","offsetWidth","offsetHeight","getClientRects","sendCustomMessageToIframe","iframeHandle","msg","msgName","messageName","iframe","contentWindow","iframeUrl","URL","src","postMessage","origin","assign","error","dispatch","targetCnt","callbackName","customEvent","CustomEvent","detail","dispatchEvent","getTargetContainer","event","cnt","globalThis","__luigi_container_manager","container","_a","source","getContainerManager","messageListener","_b","evData","_metaData","internal","params","keepBrowserHistory","registerContainer","thisComponent","containerService","DefaultCompoundRenderer","rendererObj","rendererObject","config","createCompoundContainer","createCompoundItemContainer","layoutConfig","attachCompoundItem","compoundCnt","compoundItemCnt","CustomCompoundRenderer","use","extends","superRenderer","resolveRenderer","GridCompoundRenderer","containerClass","Date","getTime","classList","mediaQueries","layouts","el","minWidth","maxWidth","mq","columns","rows","gap","innerHTML","minHeight","row","column","rendererConfig","rendererDef","registerEventListeners","eventbusListeners","navNode","nodeId","wcElement","eventListeners","evID","listenerList","listenerInfo","wcElementId","action","converter","dataConverter","deSanitizeParam","param","String","replaceAll","WebComponentService","dynamicImport","viewUrl","freeze","import","processViewUrl","attachWC","wc_id","wcItemPlaceholder","wc_container","isCompoundChild","contains","wc","initWC","replaceChild","_luigi_node","_luigi_mfe_webcomponent","Event","dispatchLuigiEvent","createClientAPI","eventBusElement","linkManager","fromContext","fromClosestContext","fromVirtualTreeRoot","nodeParams","linkManagerInstance","navigate","route","settings","link","navigationContext","withParams","updateTopNavigation","pathExists","reject","exists","openAsDrawer","drawerSettings","drawer","openAsModal","modalSettings","modal","openAsSplitView","splitViewSettings","splitView","goBack","goBackContext","hasBack","uxManager","showAlert","alertSettings","showConfirmationModal","getCurrentTheme","theme","closeUserSettings","userSettings","openUserSettings","collapseLeftSideNav","getDirtyStatus","dirtyStatus","getDocumentTitle","documentTitle","setDocumentTitle","title","removeBackdrop","hideAppLoadingIndicator","getCurrentLocale","locale","getActiveFeatureToggles","activeFeatureToggleList","publishEvent","ev","eventBus","onPublishEvent","payload","luigiClientInit","addNodeParams","getNodeParams","shouldDesanitise","paramsMap","entries","reduce","sanitizedMap","paramPair","setAnchor","getAnchor","getCoreSearchParams","searchParams","getPathParams","pathParams","getClientPermissions","clientPermissions","getUserSettings","setViewGroupData","clientAPI","__postProcess","baseURI","pathname","LuigiClient","generateWCId","charRep","normalizedViewUrl","encodeURI","location","charCodeAt","registerWCFromUrl","i18nViewUrl","checkWCUrl","module","customElements","cmpClazz","default","isPrototypeOf","define","err","catch","includeSelfRegisteredWCFromUrl","onload","_registerWebcomponent","srcString","Luigi","scriptTag","body","renderWebComponent","tagName","luigiWCFn","selfRegistered","createCompoundContainerAsync","renderer","renderWebComponentCompound","compound","ebListeners","listeners","srcNodeId","wcId","querySelector","debug","ContainerAPI","updateContext","contextObj","internalParameter","withoutSync","sendCustomMessage","mainComponent","isWebcomponent","closeAlert","dismissKey","getAllowRules","allowRules","rules","rule","join","create_if_block_1","iframe_src_value","iframe_allow_value","create_if_block","main","viewurl","$$props","label","deferInit","skipInitCheck","sandboxRules","containerInitialized","webcomponentService","initialize","$$invalidate","webComponentValue","initialized","setTimeout","deferLuigiClientWCInit","$$value","compoundConfig","compCnt","hasAttribute","customElementConstructor","notInitFn","oldValue","LuigiContainer","LuigiCompoundContainer"],"mappings":"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"}