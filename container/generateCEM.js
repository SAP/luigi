const fs = require('fs');
const path = require('path');

const luigiContainerPath = 'src/LuigiContainer.svelte';
const luigiCompoundContainerPath = 'src/LuigiCompoundContainer.svelte';
const luigiContainerTypingsPath = 'typings/LuigiContainer.svelte.d.ts';
const luigiCompoundContainerTypingsPath = 'typings/LuigiCompoundContainer.svelte.d.ts';
const luigiEventsPath = 'src/constants/communication.ts';

/**
 * Parses a `props` object from the provided file content string.
 * @param {string} fileContent - The content of the file as a string, which should contain a `props` object.
 * @returns {Object} The parsed `props` object.
 */
function parseContainerProps(fileContent) {
    const propsIndex = fileContent.indexOf('props:');
    if (propsIndex === -1) {
        throw new Error('No properties found.');
    }

    let openBraces = 0;
    let propsStart = fileContent.indexOf('{', propsIndex);
    let propsEnd = propsStart;

    for (let i = propsStart; i < fileContent.length; i++) {
        if (fileContent[i] === '{') {
            openBraces++;
        } else if (fileContent[i] === '}') {
            openBraces--;
        }

        if (openBraces === 0) {
            propsEnd = i;
            break;
        }
    }

    const propsObjectString = fileContent.slice(propsStart, propsEnd + 1);
    const propsObject = eval(`(${propsObjectString})`);

    return propsObject;
}

/**
* Generates an array of module objects based on the provided container definitions.
 *
 * @param {Array<Object>} containers - An array of container objects, each containing properties
 * needed to generate a module structure.
 * @returns {Array<Object>} An array of module objects. Each module object includes:
 *   - `kind` (string): Indicates the type of the module, set to `"javascript-module"`.
 *   - `path` (string): The file path of the module.
 *   - `declarations` (Array<Object>): Contains declaration objects, each representing a class definition.
 *   - `exports` (Array<Object>): Contains export objects that define the module exports.
 */
function generateModules(containers) {
    const modules = [];
    containers.forEach(container => {
        let module = {
            "kind": "javascript-module",
            "path": container.modulePath,
            "declarations": [
                {
                    "kind": "class",
                    "description": container.containerName,
                    "name": container.containerName,
                    "tagName": container.tagName,
                    "customElement": true,
                    "members": generateMembers(container.containerMembers, container.containerFields),
                    "events": generateEvents(container.containerEvents)
                }
            ],
            "exports": [
                {
                    "kind": "js",
                    "name": container.containerName,
                    "declaration": {
                        "name": container.containerName,
                        "module": container.module
                    }
                },
                {
                    "kind": "custom-element-definition",
                    "name": container.tagName,
                    "declaration": {
                        "name": container.containerName,
                        "module": container.module
                    }
                }
            ]
        }
        modules.push(module)
    });
    return modules;
}


/**
 * Generates the custom element manifest file
 * @param {Array} containers meta data for luigi container and luigi compound container
 * @returns 
 */
function generateCEM(containers) {
    const cem =
    {
        schemaVersion: "2.1.0",
        readme: "",
        modules: generateModules(containers)
    };
    return cem;
}

/**
 * Generates an array for the memebers in the cem objects based on provided properties and fields.
 *
 * @param {Object} props - An object representing the properties of the members. Each key is a property name,
 * and each value is an object with a `type` property describing the property's data type.
 * @param {Object} fields - An object representing the fields of the members. Each key is a field name,
 * and each value is an object with a `name` property describing the field's name.
 *
 * @returns {Array<Object>} An array of member objects, where each object represents either a field or a method:
 *   - Field members contain:
 *     - `kind` (string): The type of member, set to `"field"`.
 *     - `name` (string): The name of the field.
 *     - `type` (Object): The type of the field, generated by `generateMemberType`.
 *     - `default` (string): Default value for the field, set to `"undefined"`.
 *   - Method members contain:
 *     - `kind` (string): The type of member, set to `"method"`.
 *     - `name` (string): The name of the method.
 *
 */
function generateMembers(props, fields) {
    const members = [];
    for (let key in props) {
        let member =
        {
            "kind": "field",
            "name": key,
            "type": generateMemeberType(key, props[key]),
            "default": "undefined"
        };
        members.push(member);
    }
    for (let key in fields) {
        let field = {
            kind: "method",
            name: fields[key].name
        };
        members.push(field);
    }
    return members;
}

/**
 * Generates a member object based on the given type.
 * @param {string} type 
 */
function generateMemeberType(key, value) {
    if (value.type === 'Array') {
        return {
            "text": "Array<string>",
            "references": [
                {
                    "name": "string"
                }
            ]
        }
    } else if (value.type === 'String' || value.type === 'Object' || value.type === 'Boolean') {
        if (key === 'context' || key === 'webcomponent') {
            return { "text": "any" }
        } else {
            return {
                "text": String(value.type).toLowerCase()
            }
        }
    } else {
        return {
            "text": value.type
        }
    }
}

/**
 * Generates an array of event objects based on the provided `events` input.
 * @param {Object} events - An object containing event definitions, where each key is an event name,
 * and each value is an object with `name` and `description` properties.
 * @param {string} events[].name - The name of the event.
 * @param {string} events[].description - A description of the event.
 * @returns {Array<Object>} An array of event objects, each containing:
 *   - `name` (string): The name of the event.
 *   - `description` (string): The description of the event.
 *   - `type` (string): The fixed string `"Event"`.
 */
function generateEvents(events) {
    const eventsArray = [];
    for (let key in events) {
        let event = {
            "name": events[key].name,
            "description": events[key].description,
            "type": { text: "Event" }
        }
        eventsArray.push(event);
    }
    return eventsArray;
}

function parseContainerMethods(fileContent) {
    const constants = [];
    const lines = fileContent.split('\n');

    let inCommentBlock = false;
    let description = "";

    lines.forEach((line) => {
        line = line.trim();

        if (line.startsWith('/**')) {
            inCommentBlock = true;
            description = "";
            return;
        }

        if (inCommentBlock && line.startsWith('*')) {
            const descLine = line.replace(/^\*\s?/, '');
            description += " " + descLine;
        }

        if (line.startsWith('*/')) {
            inCommentBlock = false;
        }
        const constMatch = line.match(/(\w+)\(/);
        if (constMatch && !inCommentBlock) {
            const constName = constMatch[1];
            const constValue = constMatch[2];

            const firstSentence = description.trim().split('. ')[0] + ".";

            constants.push({
                name: constName,
                description: firstSentence.trim()
            });

            description = "";
        }
    });

    return constants;

}

/**
 * Writes the custom element manifest to a file.
 * @param {Object} cem custom element manifest file in json format 
 */
function writeFile(cem) {
    const outputPath = path.join(__dirname, 'public/dist/custom-elements.json');
    fs.writeFile(outputPath, JSON.stringify(cem, null, 2), (writeErr) => {
        if (writeErr) {
            console.error('Error to write JSON-file:', writeErr);
            return;
        }
        console.log('Created file successfully!');
    });
}

function parseContainerEvents(fileContent) {
    const constants = {};
    const lines = fileContent.split('\n');

    let inCommentBlock = false;
    let description = "";

    lines.forEach((line) => {
        line = line.trim();

        if (line.startsWith('/**')) {
            inCommentBlock = true;
            description = "";
            return;
        }

        if (inCommentBlock && line.startsWith('*')) {
            const descLine = line.replace(/^\*\s?/, '');
            description += " " + descLine;
        }

        if (line.startsWith('*/')) {
            inCommentBlock = false;
        }

        const constMatch = line.match(/^export\s+const\s+(\w+)\s*=\s*'([^']+)';/);
        if (constMatch && !inCommentBlock) {
            const constName = constMatch[1];
            const constValue = constMatch[2];

            const firstSentence = description.trim().split('. ')[0] + ".";

            constants[constName] = {
                name: constValue,
                description: firstSentence.trim()
            };

            description = "";
        }
    });

    return constants;
}

function main() {
    const getFileContent = (filePath) => fs.readFileSync(path.join(__dirname, filePath), 'utf-8');
    try {
        const luigiContainerFileContent = getFileContent(luigiContainerPath);
        const luigiCompoundContainerFileContent = getFileContent(luigiCompoundContainerPath);
        const luigiContainerTypingsContent = getFileContent(luigiContainerTypingsPath);
        const luigiCompoundContainerTypingsContent = getFileContent(luigiCompoundContainerTypingsPath);
        const eventsFileContent = getFileContent(luigiEventsPath);

        const events = parseContainerEvents(eventsFileContent);


        const containersMetaData = [
            {
                containerName: 'LuigiContainer',
                module: 'LuigiContainer.js',
                tagName: 'luigi-container',
                modulePath: 'dist/bundle.js',
                containerMembers: parseContainerProps(luigiContainerFileContent),
                containerEvents: events,
                containerFields: parseContainerMethods(luigiContainerTypingsContent)
            }, {
                containerName: 'LuigiCompoundContainer',
                module: 'LuigiCompoundContainer.js',
                tagName: 'luigi-compound-container',
                modulePath: 'dist/bundle.js',
                containerMembers: parseContainerProps(luigiCompoundContainerFileContent),
                containerEvents: events,
                containerFields: parseContainerMethods(luigiCompoundContainerTypingsContent)
            }
        ]

        const cem = generateCEM(containersMetaData);
        writeFile(cem);
    } catch (error) {
        console.error('Error: ', error.message);
    }
}

main();