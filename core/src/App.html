<div id="app" class="{hideNav? 'no-nav' : ''} {hideSideNav? 'no-side-nav' : ''}">
	{#if alert && alert.message}
    <div class="fd-alert fd-alert--error fd-alert--dismissible" role="alert" id="j2ALl423">
      <button on:click="set({alert:null})" class="fd-alert__close" aria-controls="j2ALl423" aria-label="Close"></button>
      {alert.message} {alert.link}
    </div>
	{/if}
  {#if confirmationModal.isDisplayed}
    <ConfirmationModal title={confirmationModal.title} text={confirmationModal.text} on:modalConfirm="handleModalResult(true)"
    on:modalDecline="handleModalResult(false)"></ConfirmationModal>
	{/if}
	<Backdrop>
		<div class="fd-page iframeContainer" use:init="context"></div>
	</Backdrop>
	{#if showLoadingIndicator}
    <div in:fade='{delay: 250, duration: 250}' out:fade='{duration: 250}' class="fd-page spinnerContainer" aria-hidden="false"
    aria-label="Loading">
      <div class="fd-spinner">
        <div></div>
      </div>
    </div>
	{/if}

	<TopNav pathData={navigationPath} on:handleClick="handleNavClick(event.node)"/>
  {#if !(hideNav||hideSideNav)}
	  <LeftNav pathData={navigationPath} on:handleClick="handleNavClick(event.node)"/>
  {/if}
</div>

<script type="text/javascript">
  import Backdrop from './Backdrop.html';
  import { fade } from 'svelte-transitions';
  import TopNav from './navigation/TopNav.html';
  import LeftNav from './navigation/LeftNav.html';
  import ConfirmationModal from './ConfirmationModal.html';
  import * as Routing from './services/routing.js';
  import * as Iframe from './services/iframe';
  import * as RoutingHelpers from './utilities/helpers/routing-helpers';
  import * as GenericHelpers from './utilities/helpers/generic-helpers';
  import * as AuthHelpers from './utilities/helpers/auth-helpers';

  const removeQueryParams = str => str.split('?')[0];

  const isValidBackRoute = (preservedViews, routeHash) => {
    if (preservedViews.length === 0) {
      return false;
    }
    // we're only checking the previous goBack state and
    // compare it with the new route
    const routePath = routeHash.startsWith('/') ? routeHash : `/${routeHash}`;
    const lastPreservedView = [...preservedViews].pop();
    const paths = [
      removeQueryParams(lastPreservedView.path),
      removeQueryParams(lastPreservedView.nextPath)
    ];
    return paths.includes(removeQueryParams(routePath));
  };

  const enableRouting = (component, node, config) => {
    // intial route handling
    const currentPath = Routing.getCurrentPath();
    Routing.handleRouteChange(currentPath, component, node, config);

    // subsequential route handling
    RoutingHelpers.addRouteChangeListener(path => {
      const pv = component.get().preservedViews;
      if (!isValidBackRoute(pv, path)) {
        component.set({ preservedViews: [] });
        Iframe.removeInactiveIframes(node);
      }
      Routing.handleRouteChange(path, component, node, config);
    });
  };

  const buildPath = (component, params) => {
    let path = params.link;
    if (params.fromClosestContext) {
      // from the closest navigation context
      const node = [...component.get().navigationPath]
        .reverse()
        .find(n => n.navigationContext && n.navigationContext.length > 0);
      path = Routing.concatenatePath(Routing.getNodePath(node), params.link);
    } else if (params.fromContext) {
      // from a given navigation context
      const navigationContext = params.fromContext;
      const node = component
        .get()
        .navigationPath.find(n => navigationContext === n.navigationContext);
      path = Routing.concatenatePath(Routing.getNodePath(node), params.link);
    } else if (params.relative) {
      // relative
      path = Routing.concatenatePath(
        Routing.getNodePath(component.get().currentNode),
        params.link
      );
    }

    if (params.nodeParams && Object.keys(params.nodeParams).length) {
      path += '?';
      Object.entries(params.nodeParams).forEach(entry => {
        path +=
          encodeURIComponent(
            RoutingHelpers.getContentViewParamPrefix() + entry[0]
          ) +
          '=' +
          encodeURIComponent(entry[1]) +
          '&';
      });
    }
    return path;
  };

  const addPreserveView = (component, data, config) => {
    if (data.params.preserveView) {
      const pv = component.get().preservedViews;
      const nextPath = buildPath(component, data.params);
      pv.push({
        path: Routing.getNodePath(component.get().currentNode),
        nextPath: nextPath.startsWith('/') ? nextPath : '/' + nextPath,
        context: component.get().context
      });
      component.set({ preservedViews: pv });
      // Resetting iframe config to null, since Routing.navigateTo will then create a new iframe
      // instead of using the existing instance for route.
      config.iframe = null;
    }
  };

  const handleNavigation = async (component, data, config) => {
    let path = buildPath(component, data.params);

    if (path[0] !== '/') {
      path = '/' + path; //add leading slash if necessary
    }

    addPreserveView(component, data, config);
    Routing.navigateTo(path); //navigate to the raw path. Any errors/alerts are handled later
  };

  const sendContextToClient = (component, config, goBackContext = {}) => {
    if (!config.iframe) {
      console.info('iframe does not exist, not able to send context.');
      return;
    }
    config.iframe.contentWindow.postMessage(
      {
        msg: 'luigi.init',
        context: JSON.stringify(
          Object.assign({}, component.get().context, goBackContext)
        ),
        nodeParams: JSON.stringify(Object.assign({}, component.get().nodeParams)),
        pathParams: JSON.stringify(Object.assign({}, component.get().pathParams)),
        internal: JSON.stringify(component.prepareInternalData()),
        authData: AuthHelpers.getStoredAuthData()
      },
      '*'
    );
  };

  const sendAuthDataToClient = (iframe, authData) => {
    if (!iframe || !iframe.contentWindow) {
      console.info('iframe does not exist, not able to send authData to client.');
      return;
    }
    iframe.contentWindow.postMessage(
      {
        msg: 'luigi.auth.tokenIssued',
        authData
      },
      '*'
    );
  };

  export default {
    data() {
      return {
        isNavigateBack: false,
        showLoadingIndicator: false,
        preservedViews: [
          // {
          //     path: '/project/p2/settings',
          //     nextPath: '/project/p2',
          //     context: {}
          //     iframe: Element
          // }
        ],
        confirmationModal: {
          isDisplayed: false,
          title: null,
          text: null,
          promise: null
        },
        unsavedChanges: {
          isDirty: false,
          persistUrl: null
        },
        hideSideNav: false
      };
    },
    oncreate() {},
    onstate({ changed, current, previous }) {},
    actions: {
      init(node) {
        const config = {
          iframe: null,
          navigateOk: null,
          builderCompatibilityMode: Boolean(window.builderCompatibilityMode)
        };
        window.addEventListener('popstate', async e => {
          const alert = this.get().alert;
          if (alert && alert.ttl !== undefined) {
            if (alert.ttl === 0) {
              this.set({ alert: null });
            } else {
              const updatedAlert = { ...alert };
              updatedAlert.ttl--;
              this.set({ alert: updatedAlert });
            }
          }
        });
        window.addEventListener('message', async e => {
          if ('luigi.get-context' === e.data.msg && config.iframe) {
            sendContextToClient(this, config, {});

            const loadingIndicatorAutoHideEnabled =
              GenericHelpers.getConfigValueFromObject(
                this.get(),
                'currentNode.loadingIndicator.hideAutomatically'
              ) !== false;
            if (loadingIndicatorAutoHideEnabled) {
              this.set({ showLoadingIndicator: false });
            }
          }

          if ('luigi.show-loading-indicator' === e.data.msg) {
            this.set({ showLoadingIndicator: true });
          }

          if ('luigi.hide-loading-indicator' === e.data.msg) {
            this.set({ showLoadingIndicator: false });
          }

          if ('luigi.navigate.ok' === e.data.msg) {
            config.navigateOk = true;
          }

          if ('luigi.navigation.open' === e.data.msg) {
            this.set({ isNavigateBack: false });
            this.getUnsavedChangesModalPromise().then(() => {
              handleNavigation(this, e.data, config);
            });
          }

          if ('luigi.navigation.back' === e.data.msg) {
            // go back: context from the view
            const preservedViews = this.get().preservedViews;
            if (preservedViews && preservedViews.length) {
              this.getUnsavedChangesModalPromise().then(() => {
                // remove current active iframe and data
                Iframe.setActiveIframeToPrevious(node);
                const previousActiveIframeData = preservedViews.pop();
                // set new active iframe and preservedViews
                config.iframe = Iframe.getActiveIframe(node);
                this.set({
                  isNavigateBack: true,
                  preservedViews,
                  goBackContext:
                    e.data.goBackContext && JSON.parse(e.data.goBackContext)
                });
                // TODO: check if getNavigationPath or history pop to update hash / path
                const path = handleNavigation(
                  this,
                  { params: { link: previousActiveIframeData.path } },
                  config
                );
              });
            } else {
              console.error('goBack() not possible, no preserved views found.');
            }
          }

          if ('luigi.auth.tokenIssued' === e.data.msg && config.iframe) {
            sendAuthDataToClient(config.iframe, e.data.authData);
          }

          if ('luigi.navigation.pathExists' === e.data.msg) {
            const data = e.data.data;
            const path = buildPath(this, data);
            const matchedPath = await Routing.matchPath(path);

            let normalizedPath =
              (!path.startsWith('/') ? '/' : '') +
              (path.endsWith('/') ? path.slice(0, -1) : path);
            const pathExists = matchedPath === normalizedPath;
            config.iframe.contentWindow.postMessage(
              {
                msg: 'luigi.navigation.pathExists.answer',
                data: {
                  correlationId: data.id,
                  pathExists
                }
              },
              '*'
            );
          }
          if ('luigi.set-page-dirty' === e.data.msg) {
            this.set({
              unsavedChanges: {
                isDirty: e.data.dirty || false,
                persistUrl: window.location.href
              }
            });
          }
        });

        // listeners are not automatically removed â€” cancel
        // them to prevent memory leaks
        // this.on('destroy', storeListener.cancel);

        enableRouting(this, node, config);
      }
    },
    methods: {
      prepareInternalData() {
        return {
          isNavigateBack: this.get().isNavigateBack,
          viewStackSize: this.get().preservedViews.length
        };
      },
      handleNavClick(node) {
        this.getUnsavedChangesModalPromise().then(() => {
          Routing.handleRouteClick(node);
        });
      },
      handleModalResult(result) {
        const promise = this.get().confirmationModal.promise;
        if (result) {
          this.set({
            unsavedChanges: { isDirty: false, persistUrl: null }
          });
          promise.resolve();
        } else {
          promise.reject();
        }
        this.hideModal();
      },
      getUnsavedChangesModalPromise() {
        return new Promise(resolve => {
          if (this.shouldShowUnsavedChangesModal()) {
            this.showUnsavedChangesModal().then(
              () => {
                resolve();
              },
              () => {}
            );
          } else {
            resolve();
          }
        });
      },
      shouldShowUnsavedChangesModal() {
        return (
          GenericHelpers.canComponentHandleModal(this) &&
          this.get().unsavedChanges.isDirty
        );
      },
      showUnsavedChangesModal() {
        return this.showModal(
          'Unsaved changes detected',
          'It looks like you might lose some data if you leave this page. Are you sure you want to do this?'
        );
      },
      showModal(title, text) {
        return new Promise((resolve, reject) => {
          //send the response when one of following methods were executed
          this.set({
            confirmationModal: {
              isDisplayed: true,
              title,
              text,
              promise: { resolve, reject }
            }
          });
        });
      },
      hideModal() {
        this.set({
          confirmationModal: {
            isDisplayed: false,
            title: null,
            text: null,
            promise: null
          }
        });
      }
    },

    components: {
      Backdrop,
      TopNav,
      LeftNav,
      ConfirmationModal
    },
    transitions: { fade }
  };
</script>

<style type="text/scss">
  $topNavHeight: 50px;
  $leftNavWidth: 320px;
  :global(html) {
    box-sizing: border-box;
    font-size: 14px;
  }
  :global(body) {
    -webkit-font-smoothing: antialiased;
    margin: 0;
    line-height: 1.42857;
  }
  :global(*) {
    box-sizing: inherit;
  }
  :global(*:before),
  :global(*:after) {
    box-sizing: inherit;
  }
  div :global(div) {
    font-family: '72', sans-serif;
  }

  :global(a) {
    cursor: pointer;
  }

  .iframeContainer,
  .spinnerContainer {
    position: fixed;
    top: $topNavHeight;
    left: $leftNavWidth;
    bottom: 0;
    right: 0;
    width: auto;
    min-width: auto;
    min-height: auto;
    display: block;
  }
  .iframeContainer :global(iframe) {
    border: none;
    width: 100%;
    height: 100%;
  }
  .iframeContainerNoNav {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
  }
  .iframeContainerNoNav :global(iframe) {
    border: none;
    width: 100%;
    height: 100%;
  }

  .spinnerContainer {
    background: rgba(243, 244, 245, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .no-nav {
    .iframeContainer,
    .spinnerContainer {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
    }
  }

  .no-side-nav {
    .iframeContainer,
    .spinnerContainer {
      position: fixed;
      top: $topNavHeight;
      left: 0;
      bottom: 0;
      right: 0;
    }
  }

  .fd-alert {
    position: absolute;
    min-width: 20rem;
    width: calc(100% - 2 * (#{$leftNavWidth} + 1rem));
    top: calc(#{$topNavHeight} + 1rem);
    left: calc(#{$leftNavWidth} + 1rem);
    z-index: 2;
    overflow-wrap: break-word;
    .fd-alert__close {
      cursor: pointer;
    }
  }

  @media (min-width: 600px) {
    :global(.fd-shellbar__title) {
      display: inline;
    }
  }
</style>
