<div
  id="app"
  class="{hideNav? 'no-nav' : ''} {hideSideNav? 'no-side-nav' : ''}"
>
  {#if alert && alert.message}
  <div
    class="fd-alert fd-alert--error fd-alert--dismissible"
    role="alert"
    id="j2ALl423"
  >
    <button
      on:click="set({alert:null})"
      class="fd-alert__close"
      aria-controls="j2ALl423"
      aria-label="Close"
    ></button>
    {alert.message} {alert.link}
  </div>
  {/if}
  {#if confirmationModal.isDisplayed}
  <ConfirmationModal
    content="{confirmationModal.content}"
    on:modalConfirm="handleModalResult(true)"
    on:modalDismiss="handleModalResult(false)"
  >
  </ConfirmationModal>
  {/if}
  <Backdrop>
    <div class="fd-page iframeContainer" use:init="context"></div>
  </Backdrop>
  {#if showLoadingIndicator}
  <div
    in:fade="{delay: 250, duration: 250}"
    out:fade="{duration: 250}"
    class="fd-page spinnerContainer"
    aria-hidden="false"
    aria-label="Loading"
  >
    <div class="fd-spinner"><div></div></div>
  </div>
  {/if}

  <TopNav
    pathData="{navigationPath}"
    on:handleClick="handleNavClick(event.node)"
  />
  {#if !(hideNav||hideSideNav)}
  <LeftNav
    pathData="{navigationPath}"
    on:handleClick="handleNavClick(event.node)"
  />
  {/if}
</div>

<script type="text/javascript">
  import Backdrop from './Backdrop.html';
  import { fade } from 'svelte-transitions';
  import TopNav from './navigation/TopNav.html';
  import LeftNav from './navigation/LeftNav.html';
  import ConfirmationModal from './ConfirmationModal.html';
  import { LuigiConfig } from './services/config.js';
  import * as Routing from './services/routing.js';
  import * as Navigation from './navigation/services/navigation.js';
  import * as Iframe from './services/iframe';
  import * as RoutingHelpers from './utilities/helpers/routing-helpers';
  import * as GenericHelpers from './utilities/helpers/generic-helpers';
  import * as AuthHelpers from './utilities/helpers/auth-helpers';

  const removeQueryParams = str => str.split('?')[0];

  const isValidBackRoute = (preservedViews, routeHash) => {
    if (preservedViews.length === 0) {
      return false;
    }
    // we're only checking the previous goBack state and
    // compare it with the new route
    const routePath = routeHash.startsWith('/') ? routeHash : `/${routeHash}`;
    const lastPreservedView = [...preservedViews].pop();
    const paths = [
      removeQueryParams(lastPreservedView.path),
      removeQueryParams(lastPreservedView.nextPath)
    ];
    return paths.includes(removeQueryParams(routePath));
  };

  const enableRouting = (component, node, config) => {
    // initial route handling
    const currentPath = Routing.getCurrentPath();
    Routing.handleRouteChange(currentPath, component, node, config);

    // subsequential route handling
    RoutingHelpers.addRouteChangeListener(path => {
      const pv = component.get().preservedViews;
      if (!isValidBackRoute(pv, path)) {
        component.set({ preservedViews: [] });
        Iframe.removeInactiveIframes(node);
      }
      Routing.handleRouteChange(path, component, node, config);
    });
  };

  const getSubPath = (component, node) => {
    return GenericHelpers.replaceVars(
      Routing.getNodePath(node),
      component.get().pathParams,
      ':',
      false
    );
  };

  const buildPath = (component, params) => {
    let path = params.link;
    if (params.fromClosestContext) {
      // from the closest navigation context
      const node = [...component.get().navigationPath]
        .reverse()
        .find(n => n.navigationContext && n.navigationContext.length > 0);
      path = Routing.concatenatePath(getSubPath(component, node), params.link);
    } else if (params.fromContext) {
      // from a given navigation context
      const navigationContext = params.fromContext;
      const node = component
        .get()
        .navigationPath.find(n => navigationContext === n.navigationContext);
      path = Routing.concatenatePath(getSubPath(component, node), params.link);
    } else if (params.relative) {
      // relative
      path = Routing.concatenatePath(
        getSubPath(component, component.get().currentNode),
        params.link
      );
    }

    if (params.nodeParams && Object.keys(params.nodeParams).length) {
      path += '?';
      Object.entries(params.nodeParams).forEach(entry => {
        path +=
          encodeURIComponent(
            RoutingHelpers.getContentViewParamPrefix() + entry[0]
          ) +
          '=' +
          encodeURIComponent(entry[1]) +
          '&';
      });
    }
    return path;
  };

  const addPreserveView = (component, data, config) => {
    if (data.params.preserveView) {
      const {
        preservedViews,
        currentNode,
        urlParamsRaw,
        context
      } = component.get();
      const nextPath = buildPath(component, data.params);
      preservedViews.push({
        path: Routing.getNodePath(currentNode, urlParamsRaw),
        nextPath: nextPath.startsWith('/') ? nextPath : '/' + nextPath,
        context
      });
      component.set({ preservedViews });
      // Resetting iframe config to null, since Routing.navigateTo will then create a new iframe
      // instead of using the existing instance for route.
      config.iframe = null;
    }
  };

  const handleNavigation = async (component, data, config) => {
    let path = buildPath(component, data.params);

    if (path[0] !== '/') {
      path = '/' + path; //add leading slash if necessary
    }

    addPreserveView(component, data, config);
    Routing.navigateTo(path); //navigate to the raw path. Any errors/alerts are handled later
  };

  const sendContextToClient = (component, config, goBackContext = {}) => {
    if (!config.iframe) {
      console.info('iframe does not exist, not able to send context.');
      return;
    }
    config.iframe.contentWindow.postMessage(
      {
        msg: 'luigi.init',
        context: JSON.stringify(
          Object.assign({}, component.get().context, goBackContext)
        ),
        nodeParams: JSON.stringify(
          Object.assign({}, component.get().nodeParams)
        ),
        pathParams: JSON.stringify(
          Object.assign({}, component.get().pathParams)
        ),
        internal: JSON.stringify(component.prepareInternalData()),
        authData: AuthHelpers.getStoredAuthData()
      },
      '*'
    );
  };

  const sendAuthDataToClient = (iframe, authData) => {
    if (!iframe || !iframe.contentWindow) {
      console.info(
        'iframe does not exist, not able to send authData to client.'
      );
      return;
    }
    iframe.contentWindow.postMessage(
      {
        msg: 'luigi.auth.tokenIssued',
        authData
      },
      '*'
    );
  };

  export default {
    data() {
      return {
        contentNode: undefined,
        isNavigateBack: false,
        showLoadingIndicator: false,
        preservedViews: [
          // {
          //     path: '/project/p2/settings',
          //     nextPath: '/project/p2',
          //     context: {}
          //     iframe: Element
          // }
        ],
        confirmationModal: {
          isDisplayed: false,
          content: {},
          openFromClient: false,
          promise: null
        },
        unsavedChanges: {
          isDirty: false,
          persistUrl: null
        },
        hideSideNav: false
      };
    },
    oncreate() {},
    onstate({ changed, current, previous }) {},
    actions: {
      init(node) {
        const isolateAllViews = LuigiConfig.getConfigValue(
          'navigation.defaults.isolateView'
        );
        const config = {
          iframe: null,
          navigateOk: null,
          builderCompatibilityMode: Boolean(window.builderCompatibilityMode),
          isolateAllViews
        };
        window.addEventListener('popstate', async e => {
          const alert = this.get().alert;
          if (alert && typeof alert.ttl == 'number') {
            if (alert.ttl === 0) {
              this.set({ alert: null });
            } else {
              const updatedAlert = { ...alert };
              updatedAlert.ttl--;
              this.set({ alert: updatedAlert });
            }
          }
        });
        window.addEventListener('message', async e => {
          if ('luigi.get-context' === e.data.msg && config.iframe) {
            sendContextToClient(this, config, {});

            const loadingIndicatorAutoHideEnabled =
              GenericHelpers.getConfigValueFromObject(
                this.get(),
                'currentNode.loadingIndicator.hideAutomatically'
              ) !== false;
            if (loadingIndicatorAutoHideEnabled) {
              this.set({ showLoadingIndicator: false });
            }
          }

          if ('luigi.show-loading-indicator' === e.data.msg) {
            this.set({ showLoadingIndicator: true });
          }

          if ('luigi.hide-loading-indicator' === e.data.msg) {
            this.set({ showLoadingIndicator: false });
          }

          if ('luigi.navigate.ok' === e.data.msg) {
            config.navigateOk = true;
          }

          if ('luigi.navigation.open' === e.data.msg) {
            this.set({ isNavigateBack: false });
            this.getUnsavedChangesModalPromise().then(() => {
              handleNavigation(this, e.data, config);
            });
          }

          if ('luigi.navigation.back' === e.data.msg) {
            // go back: context from the view
            const preservedViews = this.get().preservedViews;
            if (preservedViews && preservedViews.length) {
              this.getUnsavedChangesModalPromise().then(() => {
                // remove current active iframe and data
                Iframe.setActiveIframeToPrevious(node);
                const previousActiveIframeData = preservedViews.pop();
                // set new active iframe and preservedViews
                config.iframe = Iframe.getActiveIframe(node);
                this.set({
                  isNavigateBack: true,
                  preservedViews,
                  goBackContext:
                    e.data.goBackContext && JSON.parse(e.data.goBackContext)
                });
                // TODO: check if getNavigationPath or history pop to update hash / path
                const path = handleNavigation(
                  this,
                  { params: { link: previousActiveIframeData.path } },
                  config
                );
              });
            } else {
              console.error('goBack() not possible, no preserved views found.');
            }
          }

          if ('luigi.auth.tokenIssued' === e.data.msg && config.iframe) {
            sendAuthDataToClient(config.iframe, e.data.authData);
          }

          if ('luigi.navigation.pathExists' === e.data.msg) {
            const data = e.data.data;
            const path = buildPath(this, data);
            const pathData = await Navigation.getNavigationPath(
              LuigiConfig.getConfigValueAsync('navigation.nodes'),
              path
            );

            config.iframe.contentWindow.postMessage(
              {
                msg: 'luigi.navigation.pathExists.answer',
                data: {
                  correlationId: data.id,
                  pathExists: pathData.isExistingRoute
                }
              },
              '*'
            );
          }

          if ('luigi.set-page-dirty' === e.data.msg) {
            this.set({
              unsavedChanges: {
                isDirty: e.data.dirty || false,
                persistUrl: window.location.href
              }
            });
          }

          if ('luigi.ux.confirmation-modal-show' === e.data.msg) {
            this.set({ contentNode: node })
            const data = e.data.data
            this.showModal(data.content, true).then(
                () => { },
                () => { /* keep it to avoid runtime errors in browser console */ }
            );
          }
        });

        // listeners are not automatically removed — cancel
        // them to prevent memory leaks
        // this.on('destroy', storeListener.cancel);

        enableRouting(this, node, config);
      }
    },
    methods: {
      prepareInternalData() {
        return {
          isNavigateBack: this.get().isNavigateBack,
          viewStackSize: this.get().preservedViews.length
        };
      },
      handleNavClick(node) {
        this.getUnsavedChangesModalPromise().then(() => {
          Routing.handleRouteClick(node, this.get());
        });
      },
      handleModalResult(result) {
        const { promise, openFromClient } = this.get().confirmationModal;
        if (result) {
          this.set({
            unsavedChanges: { isDirty: false, persistUrl: null }
          });
          promise.resolve();
        } else {
          promise.reject();
        }
        if (openFromClient) {
          Iframe.getActiveIframe(this.get().contentNode).contentWindow.postMessage(
            {
              msg: 'luigi.ux.confirmationModal.hide',
              data: { confirmed: result }
            },
            '*'
          );
        }
        this.hideModal();
      },
      getUnsavedChangesModalPromise() {
        return new Promise(resolve => {
          if (this.shouldShowUnsavedChangesModal()) {
            this.showUnsavedChangesModal().then(
              () => { resolve(); },
              () => {}
            );
          } else {
            resolve();
          }
        });
      },
      shouldShowUnsavedChangesModal() {
        return (
          GenericHelpers.canComponentHandleModal(this) &&
          this.get().unsavedChanges.isDirty
        );
      },
      showUnsavedChangesModal() {
        return this.showModal(
          {
            header: 'Unsaved changes detected',
            body: 'It looks like you might lose some data if you leave this page. Are you sure you want to do this?',
            buttonDismiss: 'No',
            buttonConfirm: 'Yes'
          }
        );
      },
      showModal(content, openFromClient = false) {
        return new Promise((resolve, reject) => {
          //send the response when one of following methods were executed
          this.set({
            confirmationModal: {
              isDisplayed: true,
              content,
              openFromClient,
              promise: { resolve, reject }
            }
          })
        })
      },
      hideModal() {
        this.set({
          confirmationModal: {
            isDisplayed: false,
            content: {},
            openFromClient: false,
            promise: null
          }
        });
      },
    },

    components: {
      Backdrop,
      TopNav,
      LeftNav,
      ConfirmationModal
    },
    transitions: { fade }
  };
</script>

<style type="text/scss">
  $topNavHeight: 48px;
  $leftNavWidth: 320px;
  :global(html) {
    box-sizing: border-box;
    font-size: 14px;
  }
  :global(body) {
    -webkit-font-smoothing: antialiased;
    margin: 0;
    line-height: 1.42857;
  }
  :global(*) {
    box-sizing: inherit;
  }
  :global(*:before),
  :global(*:after) {
    box-sizing: inherit;
  }
  div :global(div) {
    font-family: '72', sans-serif;
  }

  :global(a) {
    cursor: pointer;
  }

  .iframeContainer,
  .spinnerContainer {
    position: fixed;
    top: $topNavHeight;
    left: $leftNavWidth;
    bottom: 0;
    right: 0;
    width: auto;
    min-width: auto;
    min-height: auto;
    display: block;
  }
  .iframeContainer :global(iframe) {
    border: none;
    width: 100%;
    height: 100%;
  }
  .iframeContainerNoNav {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
  }
  .iframeContainerNoNav :global(iframe) {
    border: none;
    width: 100%;
    height: 100%;
  }

  .spinnerContainer {
    background: rgba(243, 244, 245, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .no-nav {
    .iframeContainer,
    .spinnerContainer {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
    }
  }

  .no-side-nav {
    .iframeContainer,
    .spinnerContainer {
      position: fixed;
      top: $topNavHeight;
      left: 0;
      bottom: 0;
      right: 0;
    }
  }

  .fd-alert {
    position: absolute;
    min-width: 20rem;
    width: calc(100% - 2 * (#{$leftNavWidth} + 1rem));
    top: calc(#{$topNavHeight} + 1rem);
    left: calc(#{$leftNavWidth} + 1rem);
    z-index: 2;
    overflow-wrap: break-word;
    .fd-alert__close {
      cursor: pointer;
    }
  }

  @media (min-width: 600px) {
    :global(.fd-shellbar__title) {
      display: inline;
    }
  }
</style>
